package trashsoftware.deepSearcher2;
import trashsoftware.deepSearcher2.fxml.Client;
import trashsoftware.deepSearcher2.util.EventLogger;
public class Main {
    public static void main(String[] args) throws Exception {
        try {
            Client.startClient();
        } catch (Exception e) {
            EventLogger.log(e);
            e.printStackTrace();
        }
    }
}
module DeepSearcher {
    requires javafx.fxml;
    requires javafx.controls;
    requires java.desktop;
    requires org.json;
    requires org.apache.commons.codec;
    requires org.apache.commons.collections4;
    requires org.apache.commons.compress;
    requires org.apache.pdfbox;
    requires poi.ooxml;
    requires poi.scratchpad;
    requires poi;
    opens trashsoftware.deepSearcher2;
    opens trashsoftware.deepSearcher2.guiItems;
    opens trashsoftware.deepSearcher2.fxml;
    opens trashsoftware.deepSearcher2.fxml.widgets;
    opens trashsoftware.deepSearcher2.fxml.settingsPages;
    exports trashsoftware.deepSearcher2.fxml;
    exports trashsoftware.deepSearcher2.searcher;
    exports trashsoftware.deepSearcher2.searcher.matchers;
    exports trashsoftware.deepSearcher2.guiItems;
    exports trashsoftware.deepSearcher2.util;
    exports trashsoftware.deepSearcher2.fxml.widgets;
    exports trashsoftware.deepSearcher2.fxml.settingsPages;
}
package trashsoftware.deepSearcher2.fxml;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.Label;
import java.net.URL;
import java.util.ResourceBundle;
public class AboutViewController implements Initializable {
    @FXML
    Label authorLabel;
    @FXML
    Label versionLabel;
    @Override
    public void initialize(URL url, ResourceBundle resourceBundle) {
        versionLabel.setText(Client.VERSION);
        if ("CN".equals(resourceBundle.getLocale().getCountry())) {
            authorLabel.setText(Client.AUTHOR_ZH);
        } else {
            authorLabel.setText(Client.AUTHOR_EN);
        }
    }
}
package trashsoftware.deepSearcher2.fxml;
import javafx.application.Application;
import javafx.application.Platform;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Alert;
import javafx.scene.image.Image;
import javafx.stage.Stage;
import trashsoftware.deepSearcher2.util.Cache;
import trashsoftware.deepSearcher2.util.Configs;
import trashsoftware.deepSearcher2.util.EventLogger;
import java.io.File;
import java.io.IOException;
import java.util.ResourceBundle;
public class Client extends Application {
    public static final String AUTHOR_ZH = "张博涵";
    public static final String AUTHOR_EN = "Bohan Zhang";
    public static final String VERSION = "1.0";
    /**
     * Name of a file which marks the program is running. Create on launch and delete on exit.
     */
    private static final String RUNNING_MARK = ".running";
    private static ResourceBundle bundle;
    private static Image iconImage;
    private static Stage currentStage;
    public static void startClient() {
        launch();
    }
    public static void restartClient() {
        currentStage.close();
        Platform.runLater(() -> {
            try {
                new Client().showMainUi(new Stage());
            } catch (Exception e) {
                EventLogger.log(e);
                e.printStackTrace();
            }
        });
    }
    public static ResourceBundle getBundle() {
        return bundle;
    }
    public static Image getIconImage() {
        return iconImage;
    }
    private static void createRunningMarkFile() throws IOException {
        File file = new File(RUNNING_MARK);
        if (!file.createNewFile()) throw new IOException("Cannot create mark file. ");
    }
    private static boolean isRunning() {
        File file = new File(RUNNING_MARK);
        return file.exists();
    }
    private static void deleteMarkFile() {
        File file = new File(RUNNING_MARK);
        if (!file.delete()) {
            System.gc();
            if (!file.delete()) {
                Alert alert = new Alert(Alert.AlertType.ERROR);
                alert.setTitle(bundle.getString("error"));
                alert.setHeaderText(bundle.getString("cannotDeleteFile"));
                alert.setContentText(bundle.getString("pleaseManualDelete") + " " + file.getAbsolutePath());
                alert.show();
            }
        }
    }
    @Override
    public void start(Stage primaryStage) throws Exception {
        showMainUi(primaryStage);
    }
    private void showMainUi(Stage stage) throws Exception {
        Configs.startConfig();
        bundle = ResourceBundle.getBundle("trashsoftware.deepSearcher2.bundles.LangBundle",
                Configs.getConfigs().getCurrentLocale());
        if (isRunning()) {
            Configs.stopConfig();
            Alert alert = new Alert(Alert.AlertType.WARNING);
            alert.setTitle(bundle.getString("appName"));
            alert.setHeaderText(bundle.getString("warning"));
            alert.setContentText(bundle.getString("appName") + " " + bundle.getString("alreadyRunning"));
            alert.show();
            return;
        }
        Cache.startCache();
        currentStage = stage;
        FXMLLoader loader =
                new FXMLLoader(getClass().getResource("/trashsoftware/deepSearcher2/fxml/mainView.fxml"),
                        bundle);
        Parent root = loader.load();
        MainViewController controller = loader.getController();
        iconImage = new Image(getClass().getResourceAsStream("/trashsoftware/deepSearcher2/images/icon.bmp"));
        Scene rootScene = new Scene(root);
        rootScene.getStylesheets().add(
                getClass().getResource("/trashsoftware/deepSearcher2/css/defaultTheme.css").toExternalForm());
        if (Configs.getConfigs().isUseCustomFont()) {
            Configs.getConfigs().applyCustomFont(rootScene);
            controller.rescaleUi(Configs.getConfigs().getFontSize(12));
        }
        stage.setTitle(bundle.getString("appName"));
        stage.getIcons().add(iconImage);
        stage.setScene(rootScene);
        controller.setStage(stage);
        Cache.getCache().addObservable(controller);
        stage.setOnHidden(e -> {
            controller.stopActiveSearcher();
            deleteMarkFile();
            Cache.stopCache();
            Configs.stopConfig();
        });
        createRunningMarkFile();
        stage.show();
    }
}
package trashsoftware.deepSearcher2.fxml;
import javafx.application.Platform;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.stage.Modality;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.stage.Window;
import trashsoftware.deepSearcher2.util.Configs;
import java.io.IOException;
import java.net.URL;
import java.util.ResourceBundle;
/**
 * A utility window that ask user to confirm.
 * <p>
 * This window provides a message box, a confirm button, and a cancel button.
 */
public class ConfirmBox implements Initializable {
    @FXML
    Label messageBox;
    @FXML
    Button confirmButton;
    private Stage stage;
    private Runnable onConfirmed;
    private Runnable onCancelled;
    /**
     * Creates a new confirm box, but does not show it.
     *
     * @param ownerWindow the parent window, which will be blocked by this confirm box
     * @return the new instance
     */
    public static ConfirmBox createConfirmBox(Window ownerWindow) {
        try {
            FXMLLoader loader = new FXMLLoader(
                    ConfirmBox.class.getResource("/trashsoftware/deepSearcher2/fxml/confirmBox.fxml"),
                    Client.getBundle());
            Parent root = loader.load();
            Stage stage = new Stage();
            stage.setTitle(Client.getBundle().getString("pleaseConfirm"));
            stage.initStyle(StageStyle.UTILITY);
            stage.initModality(Modality.APPLICATION_MODAL);
            stage.initOwner(ownerWindow);
            Scene scene = new Scene(root);
            if (Configs.getConfigs().isUseCustomFont()) {
                Configs.getConfigs().applyCustomFont(scene);
            }
            stage.setScene(scene);
            ConfirmBox controller = loader.getController();
            controller.stage = stage;
            return controller;
        } catch (IOException e) {
            throw new RuntimeException(e.getMessage());
        }
    }
    @Override
    public void initialize(URL url, ResourceBundle resourceBundle) {
    }
    @FXML
    void onConfirmed() {
        if (onConfirmed != null) Platform.runLater(onConfirmed);
        stage.close();
    }
    @FXML
    void onCancelled() {
        if (onCancelled != null) Platform.runLater(onCancelled);
        stage.close();
    }
    /**
     * Sets the text shown on the confirm button.
     *
     * @param text text to show
     */
    public void setConfirmButtonText(String text) {
        confirmButton.setText(text);
    }
    /**
     * Shows the confirm box until user selects a result or closes the window.
     */
    public void show() {
        stage.showAndWait();
    }
    /**
     * Sets the message shown in the message box
     *
     * @param message text to show
     */
    public void setMessage(String message) {
        messageBox.setText(message);
    }
    /**
     * Sets the action if confirm button is clicked
     *
     * @param eventHandler on confirm action
     */
    public void setOnConfirmed(Runnable eventHandler) {
        this.onConfirmed = eventHandler;
    }
    /**
     * Sets the action if cancel button is clicked
     *
     * @param eventHandler on cancel action
     */
    @SuppressWarnings("unused")
    public void setOnCancelled(Runnable eventHandler) {
        this.onCancelled = eventHandler;
    }
}
package trashsoftware.deepSearcher2.fxml;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.Label;
import javafx.scene.control.TableView;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.layout.ColumnConstraints;
import javafx.scene.layout.GridPane;
import javafx.stage.Stage;
import trashsoftware.deepSearcher2.guiItems.HistoryItem;
import trashsoftware.deepSearcher2.util.Configs;
import java.net.URL;
import java.util.List;
import java.util.ResourceBundle;
public class HistoryListController implements Initializable {
    @FXML
    GridPane rightPane;
    @FXML
    ColumnConstraints rightColumn;
    @FXML
    TableView<HistoryItem> historyTable;
    @FXML
    Label pattern, dirSearched, searchedTime;
    private Stage stage;
    @Override
    public void initialize(URL url, ResourceBundle resourceBundle) {
        setTableFactory();
        addTableListener();
        fillTable();
    }
    void setStage(Stage stage) {
        this.stage = stage;
    }
    private void setTableFactory() {
        historyTable.getColumns().get(0).setCellValueFactory(new PropertyValueFactory<>("pattern"));
        historyTable.getColumns().get(1).setCellValueFactory(new PropertyValueFactory<>("dirSearched"));
        historyTable.getColumns().get(2).setCellValueFactory(new PropertyValueFactory<>("dateTime"));
    }
    private void addTableListener() {
        historyTable.getSelectionModel().selectedItemProperty()
                .addListener(((observableValue, historyItem, t1) -> {
                    if (t1 != null) showItem(t1);
                }));
    }
    @FXML
    void clearHistoryAction() {
        ConfirmBox confirmBox = ConfirmBox.createConfirmBox(stage);
        confirmBox.setMessage(Client.getBundle().getString("confirmClearHistory"));
        confirmBox.setOnConfirmed(() -> {
            Configs.clearAllHistory();
            hideRightPane();
            fillTable();
        });
        confirmBox.show();
    }
    private void showItem(HistoryItem historyItem) {
        showRightPane();
        pattern.setText(historyItem.getPatternLines());
        dirSearched.setText(historyItem.getDirSearchedLines());
        searchedTime.setText(historyItem.getDateTime());
    }
    private void showRightPane() {
        rightPane.setManaged(true);
        rightPane.setVisible(true);
        stage.sizeToScene();
    }
    private void hideRightPane() {
        rightPane.setManaged(false);
        rightPane.setVisible(false);
        stage.sizeToScene();
    }
    private void fillTable() {
        historyTable.getItems().clear();
        List<HistoryItem> allHistory = Configs.getAllHistory();
        historyTable.getItems().addAll(allHistory);
    }
}
package trashsoftware.deepSearcher2.fxml;
import javafx.application.Platform;
import javafx.beans.binding.Bindings;
import javafx.beans.property.ReadOnlyStringWrapper;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.concurrent.Service;
import javafx.concurrent.Task;
import javafx.event.EventHandler;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.MenuItem;
import javafx.scene.control.TextField;
import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.control.cell.TextFieldListCell;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.GridPane;
import javafx.scene.text.Text;
import javafx.stage.DirectoryChooser;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.util.Callback;
import javafx.util.Duration;
import javafx.util.StringConverter;
import org.json.JSONArray;
import org.json.JSONObject;
import trashsoftware.deepSearcher2.fxml.settingsPages.SearchingOptionsPage;
import trashsoftware.deepSearcher2.fxml.widgets.FormatTable;
import trashsoftware.deepSearcher2.fxml.widgets.TextFieldList;
import trashsoftware.deepSearcher2.guiItems.FormatFilterItem;
import trashsoftware.deepSearcher2.guiItems.FormatItem;
import trashsoftware.deepSearcher2.guiItems.FormatType;
import trashsoftware.deepSearcher2.guiItems.ResultItem;
import trashsoftware.deepSearcher2.searcher.*;
import trashsoftware.deepSearcher2.util.*;
import java.awt.*;
import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.util.List;
import java.util.*;
public class MainViewController implements Initializable, CacheObservable {
    private final ResourceBundle fileTypeBundle =
            ResourceBundle.getBundle("trashsoftware.deepSearcher2.bundles.FileTypeBundle",
                    Configs.getConfigs().getCurrentLocale());
    @FXML
    GridPane basePane;
    @FXML
    TableView<ResultItem> resultTable;
    @FXML
    TableColumn<ResultItem, String> fileNameCol;
    @FXML
    TableColumn<ResultItem, String> matchingModeCol;
    @FXML
    TableColumn<FormatItem, String> formatNameCol;
    @FXML
    FormatTable formatTable;
    @FXML
    TextFieldList searchItemsList;
    @FXML
    ListView<File> dirList;
    @FXML
    ToggleGroup andOrGroup;
    @FXML
    RadioButton matchAllRadioBtn, matchAnyRadioBtn;
    @FXML
    CheckBox searchFileNameBox, searchDirNameBox, searchContentBox;
    @FXML
    CheckBox matchCaseBox, matchWordBox, matchRegexBox;
    @FXML
    CheckBox selectAllBox;
    @FXML
    CheckMenuItem showFullPathMenu, showExtMenu;
    @FXML
    ComboBox<FormatFilterItem> filterBox;
    @FXML
    Button searchButton;
    @FXML
    Button deleteDirButton, deleteTargetButton;
    @FXML
    Label searchingStatusText, resultNumberText, statusSuffixText, timeUsedLabelText, timeUsedText, timeUnitText;
    @FXML
    ProgressIndicator progressIndicator;
    private ResourceBundle bundle;
    private Stage thisStage;
    private boolean isSearching;
    private File dirDialogInitFile;
    private SearchService service;
    private ChangeListener<Number> fileCountListener;
    private boolean showingSelectAll = true;
    @Override
    public void initialize(URL url, ResourceBundle resourceBundle) {
        bundle = resourceBundle;
        setDirListFactory();
        setResultTableFactory();
        setFormatTableFactory();
        addFileNameColumnHoverListener();
        addMatchingModeColumnHoverListener();
        addFormatNameColumnHoverListener();
        addResultTableClickListeners();
        addTargetListListener();
        addCheckBoxesListeners();
        addCheckMenuListeners();
        addFilterBoxListener();
        addSearchItem();  // Add a default search field
        fillFormatTable();
        fillFilterBox();
        filterBox.getSelectionModel().select(0);  // this step must run after 'fillFormatTable()'
        initContextMenus();
        // restore saved status
        // this should be called after all listeners are set
        loadFromCache();
    }
    public void setStage(Stage stage) {
        thisStage = stage;
    }
    public void rescaleUi(int fontSize) {
        double defaultC1 = basePane.getColumnConstraints().get(0).getPercentWidth();
        double expectedTimes = 1 + ((double) fontSize / 12 - 1) * 0.75;
        double times = Math.max(0.75, Math.min(2, expectedTimes));
        double percentageWidth1 = times * defaultC1;
        double percentageWidth2 = 100 - percentageWidth1;
        basePane.getColumnConstraints().get(1).setPercentWidth(percentageWidth2);
        basePane.getColumnConstraints().get(0).setPercentWidth(percentageWidth1);
    }
    // Controls
    @FXML
    void addSearchDir() {
        DirectoryChooser dc = new DirectoryChooser();
        if (dirDialogInitFile != null && dirDialogInitFile.exists())
            dc.setInitialDirectory(dirDialogInitFile);
        File dir = dc.showDialog(thisStage);
        if (dir != null) {
            if (!dirList.getItems().contains(dir)) {
                dirList.getItems().add(dir);
                dirDialogInitFile = dir.getParentFile();
            }
        }
    }
    @FXML
    void addSearchItem() {
        TextField textField = new TextField();
        textField.setPromptText(bundle.getString("searchPrompt"));
        textField.setOnAction(e -> {  // the action of pressing 'Enter' in text field
            if (!isSearching) startSearching();
        });
        searchItemsList.getTextFields().add(textField);
    }
    @FXML
    void deleteSearchDir() {
        int index = dirList.getSelectionModel().getSelectedIndex();
        dirList.getItems().remove(index);
    }
    @FXML
    void deleteSearchItem() {
        int index = searchItemsList.getSelectedIndex();
        searchItemsList.getTextFields().remove(index);
    }
    @FXML
    void searchAction() {
        if (isSearching) {
            cancelSearching();
        } else {
            startSearching();
        }
    }
    @FXML
    void selectAllAction() {
        if (showingSelectAll) {
            selectAllFormats();
            selectAllBox.setText(bundle.getString("deselectAll"));
        } else {
            deselectAllFormats();
            selectAllBox.setText(bundle.getString("selectAll"));
        }
        showingSelectAll = !showingSelectAll;
    }
    @FXML
    void openSettingsAction() throws IOException {
        openSettings();
    }
    @FXML
    void openHistoryAction() throws IOException {
        FXMLLoader loader = new FXMLLoader(
                getClass().getResource("/trashsoftware/deepSearcher2/fxml/historyListView.fxml"), bundle);
        Parent root = loader.load();
        Stage stage = new Stage();
        stage.initOwner(thisStage);
        stage.initStyle(StageStyle.UTILITY);
        stage.setTitle(bundle.getString("history"));
        stage.getIcons().add(Client.getIconImage());
        Scene scene = new Scene(root);
        if (Configs.getConfigs().isUseCustomFont()) {
            Configs.getConfigs().applyCustomFont(scene);
        }
        stage.setScene(scene);
        HistoryListController controller = loader.getController();
        controller.setStage(stage);
        stage.show();
    }
    @FXML
    void openAboutAction() throws IOException {
        FXMLLoader loader = new FXMLLoader(
                getClass().getResource("/trashsoftware/deepSearcher2/fxml/aboutView.fxml"), bundle);
        Parent root = loader.load();
        Stage stage = new Stage();
        stage.initOwner(thisStage);
        stage.initStyle(StageStyle.UTILITY);
        stage.setTitle(bundle.getString("appName"));
        stage.getIcons().add(Client.getIconImage());
        stage.setScene(new Scene(root));
        stage.show();
    }
    @FXML
    void moreOptionAction() throws IOException {
        SettingsPanelController controller = openSettings();
        controller.expandUntil(SearchingOptionsPage.class);
    }
    @FXML
    void exitAction() {
        thisStage.close();
    }
    @FXML
    void restartAction() {
        Client.restartClient();
    }
    @Override
    public void putCache(JSONObject rootObject) {
        rootObject.put("searchFileName", searchFileNameBox.isSelected());
        rootObject.put("searchDirName", searchDirNameBox.isSelected());
        rootObject.put("searchContent", searchContentBox.isSelected());
        rootObject.put("matchCase", matchCaseBox.isSelected());
        rootObject.put("matchWord", matchWordBox.isSelected());
        rootObject.put("matchRegex", matchRegexBox.isSelected());
        rootObject.put("matchAll", matchAllRadioBtn.isSelected());
        rootObject.put("showFullPath", showFullPathMenu.isSelected());
        rootObject.put("showExt", showExtMenu.isSelected());
        if (dirDialogInitFile != null) rootObject.put("dirDialogInit", dirDialogInitFile.getAbsolutePath());
        rootObject.put(Cache.OPENED_DIRS_KEY, new JSONArray(dirList.getItems()));
        JSONArray selectedFmts = new JSONArray();
        for (FormatItem fi : formatTable.getItems()) {
            if (fi.getCheckBox().isSelected()) selectedFmts.put(fi.getExtension());
        }
        rootObject.put(Cache.FORMATS_KEY, selectedFmts);
    }
    @Override
    public void loadFromCache(Cache cache) {
        restoreSavedFormats(cache);
        restoreLastOpenedDirs(cache);
        loadRadioButtonsInitialStatus(cache);
        loadSavedCheckBoxesStatus(cache);
        loadSavedCheckMenusStatus(cache);
        String initD = cache.getStringCache("dirDialogInit");
        if (initD != null) dirDialogInitFile = new File(initD);
    }
    /**
     * Stops the current running searcher, if exists.
     * <p>
     * This method is used when the program is closed by user while a searcher is running.
     */
    public void stopActiveSearcher() {
        if (service != null) {
            service.getSearcher().stop();
        }
    }
    private void loadFromCache() {
        loadFromCache(Cache.getCache());
    }
    private void clearSearchDirs() {
        dirList.getItems().clear();
    }
    private void clearSearchItems() {
        searchItemsList.getTextFields().clear();
    }
    private SettingsPanelController openSettings() throws IOException {
        FXMLLoader loader = new FXMLLoader(
                getClass().getResource("/trashsoftware/deepSearcher2/fxml/settingsPanel.fxml"), bundle);
        Parent root = loader.load();
        Stage stage = new Stage();
        stage.initOwner(thisStage);
        stage.initStyle(StageStyle.UTILITY);
        stage.setTitle(bundle.getString("settings"));
        stage.getIcons().add(Client.getIconImage());
        Scene scene = new Scene(root);
        if (Configs.getConfigs().isUseCustomFont()) {
            Configs.getConfigs().applyCustomFont(scene);
        }
        stage.setScene(scene);
        SettingsPanelController controller = loader.getController();
        controller.setStage(stage, this);
        stage.show();
        return controller;
    }
    // Factories and listeners
    private void setDirListFactory() {
        dirList.setCellFactory(TextFieldListCell.forListView(new StringConverter<>() {
            @Override
            public String toString(File object) {
                return object.getAbsolutePath();
            }
            @Override
            public File fromString(String string) {
                return new File(string);
            }
        }));
        dirList.setEditable(true);
        dirList.setOnEditCommit(event -> {
            File nv = event.getNewValue();
            if (nv.exists()) {
                dirList.getItems().set(event.getIndex(), nv);
            }
        });
        dirList.getSelectionModel().selectedIndexProperty().addListener((observable, oldValue, newValue) ->
                deleteDirButton.setDisable(newValue.intValue() == -1));
    }
    private void setResultTableFactory() {
        TableColumn<ResultItem, ?> fileSizeCol = resultTable.getColumns().get(1);
        TableColumn<ResultItem, ?> fileTypeCol = resultTable.getColumns().get(2);
        TableColumn<ResultItem, ?> matchModeCol = resultTable.getColumns().get(3);
        fileNameCol.setCellValueFactory(param -> {
            File file = param.getValue().getFile();
            String name = showFullPathMenu.isSelected() ? file.getAbsolutePath() : file.getName();
            if (!showExtMenu.isSelected() && !file.isDirectory()) {
                int dotIndex = name.lastIndexOf('.');
                if (dotIndex > 0) name = name.substring(0, dotIndex);
            }
            return new ReadOnlyStringWrapper(name);
        });
        fileSizeCol.setCellValueFactory(new PropertyValueFactory<>("Size"));
        fileTypeCol.setCellValueFactory(new PropertyValueFactory<>("Type"));
        matchModeCol.setCellValueFactory(new PropertyValueFactory<>("Mode"));
    }
    private void setFormatTableFactory() {
        TableColumn<FormatItem, ?> checkCol = formatTable.getColumns().get(0);
        TableColumn<FormatItem, ?> descriptionCol = formatTable.getColumns().get(1);
        TableColumn<FormatItem, ?> extCol = formatTable.getColumns().get(2);
        checkCol.setCellValueFactory(new PropertyValueFactory<>("CheckBox"));
        descriptionCol.setCellValueFactory(new PropertyValueFactory<>("Description"));
        extCol.setCellValueFactory(new PropertyValueFactory<>("DottedExtension"));
    }
    private void addFileNameColumnHoverListener() {
        fileNameCol.setCellFactory(new ResTableCallback<>(resultTable) {
            @Override
            protected String tooltipText(ResultItem cellData) {
                return cellData.getFile().getAbsolutePath();
            }
        });
    }
    private void addFormatNameColumnHoverListener() {
        formatNameCol.setCellFactory(new ResTableCallback<>(formatTable) {
            @Override
            protected String tooltipText(FormatItem cellData) {
                return cellData.getDescription();
            }
        });
    }
    private void addMatchingModeColumnHoverListener() {
        matchingModeCol.setCellFactory(new Callback<>() {
            @Override
            public TableCell<ResultItem, String> call(TableColumn<ResultItem, String> param) {
                return new TableCell<>() {
                    @Override
                    protected void updateItem(String item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item == null || empty) {
                            setText(null);
                        } else {
                            setText(item);
                            hoverProperty().addListener((ObservableValue<? extends Boolean> obs, Boolean wasHovered,
                                                         Boolean isNowHovered) -> {
                                if (isNowHovered && !isEmpty()) {
                                    ResultItem res = getTableRow().getItem();
                                    String tips;
                                    if (res != null && (tips = res.showInfo()) != null) {
                                        Tooltip tp = new Tooltip();
                                        tp.setShowDuration(new Duration(10000));
                                        tp.setText(tips);
                                        resultTable.setTooltip(tp);
                                        return;
                                    }
                                }
                                resultTable.setTooltip(null);
                            });
                        }
                    }
                };
            }
        });
    }
    private void addFilterBoxListener() {
        filterBox.getSelectionModel().selectedItemProperty().addListener(((observableValue, formatFilterItem, t1) ->
                formatTable.setFilter(t1)));
    }
    private void addResultTableClickListeners() {
        resultTable.setRowFactory(tableView -> {
            final TableRow<ResultItem> row = new TableRow<>();
            final ContextMenu contextMenu = new ContextMenu();
            final MenuItem openFileMenu = new MenuItem(bundle.getString("openFile"));
            final MenuItem openLocationMenu = new MenuItem(bundle.getString("openFileLocation"));
            openFileMenu.setOnAction(event -> openFile(row.getItem().getFile()));
            openLocationMenu.setOnAction(event -> openFile(row.getItem().getFile().getParentFile()));
            contextMenu.getItems().addAll(openFileMenu, openLocationMenu);
            // Set context menu on row, but use a binding to make it only show for non-empty rows:
            row.setOnMouseClicked(mouseEvent -> {
                if (mouseEvent.getButton() == MouseButton.PRIMARY && mouseEvent.getClickCount() == 2) {
                    openFile(row.getItem().getFile());
                }
            });
            row.contextMenuProperty().bind(
                    Bindings.when(row.emptyProperty())
                            .then((ContextMenu) null)
                            .otherwise(contextMenu)
            );
            return row;
        });
    }
    private void addTargetListListener() {
        searchItemsList.selectedIndexProperty().addListener(((observableValue, number, t1) ->
                deleteTargetButton.setDisable(t1.intValue() == -1)));
    }
    private void addCheckBoxesListeners() {
        searchContentBox.selectedProperty().addListener((observableValue, aBoolean, t1) -> {
            if (t1) {
                formatTable.setDisable(false);
                selectAllBox.setDisable(false);
                filterBox.setDisable(false);
            } else {
                formatTable.setDisable(true);
                selectAllBox.setDisable(true);
                filterBox.setDisable(true);
            }
        });
        matchWordBox.selectedProperty().addListener(((observableValue, aBoolean, t1) -> {
            if (t1) {
                matchRegexBox.setSelected(false);
            }
        }));
        matchRegexBox.selectedProperty().addListener(((observableValue, aBoolean, t1) -> {
            if (t1) {
                matchWordBox.setSelected(false);
            }
        }));
    }
    private void addCheckMenuListeners() {
        showFullPathMenu.selectedProperty().addListener(((observable, oldValue, newValue) ->
                resultTable.refresh()));
        showExtMenu.selectedProperty().addListener(((observable, oldValue, newValue) ->
                resultTable.refresh()));
    }
    // Helper functions
    private JSONArray lastOpenedDirs(Cache cache) {
        return cache.getArrayCache(Cache.OPENED_DIRS_KEY);
    }
    private void loadRadioButtonsInitialStatus(Cache cache) {
        boolean isAll = cache.getBooleanCache("matchAll", false);
        matchAllRadioBtn.setSelected(isAll);
        matchAnyRadioBtn.setSelected(!isAll);
    }
    private void loadSavedCheckBoxesStatus(Cache cache) {
        setBoxInitialStatus(searchFileNameBox, "searchFileName", cache);
        setBoxInitialStatus(searchDirNameBox, "searchDirName", cache);
        setBoxInitialStatus(searchContentBox, "searchContent", cache);
        setBoxInitialStatus(matchCaseBox, "matchCase", cache);
        setBoxInitialStatus(matchWordBox, "matchWord", cache);
        setBoxInitialStatus(matchRegexBox, "matchRegex", cache);
    }
    private void loadSavedCheckMenusStatus(Cache cache) {
        showFullPathMenu.setSelected(cache.getBooleanCache("showFullPath", true));
        showExtMenu.setSelected(cache.getBooleanCache("showExt", true));
    }
    private void setBoxInitialStatus(CheckBox checkBox, String key, Cache cache) {
        boolean checked = cache.getBooleanCache(key, false);
        checkBox.setSelected(checked);
    }
    public void refreshFormatTable() {
        Set<String> selected = formatTable.getSelectedFormats();
        formatTable.initialize();
        fillFormatTable();
        formatTable.selectFormats(selected);
        // manually trigger the change listener of filters
        int index = filterBox.getSelectionModel().getSelectedIndex();
        filterBox.getSelectionModel().select(index == 0 ? 1 : 0);
        filterBox.getSelectionModel().select(index);
    }
    private void fillFormatTable() {
        Enumeration<String> keys = fileTypeBundle.getKeys();
        while (keys.hasMoreElements()) {
            String key = keys.nextElement();
            FormatItem formatItem = new FormatItem(key, fileTypeBundle.getString(key));
            formatTable.addItem(formatItem);
        }
        Map<String, String> customFormats = Configs.getConfigs().getAllCustomFormats();
        for (Map.Entry<String, String> extDes : customFormats.entrySet()) {
            FormatItem formatItem = new FormatItem(extDes.getKey(), extDes.getValue());
            formatTable.addItem(formatItem);
        }
        formatTable.setCustomFormats(customFormats);
        Collections.sort(formatTable.getAllItems());
    }
    private void fillFilterBox() {
        filterBox.getItems().clear();
        filterBox.getItems().addAll(
                new FormatFilterItem(FormatType.ALL, bundle.getString("allFiles"), formatTable),
                new FormatFilterItem(FormatType.TEXT, bundle.getString("textFiles"), formatTable),
                new FormatFilterItem(FormatType.CODES, bundle.getString("sourceCodeFiles"), formatTable),
                new FormatFilterItem(FormatType.MS_OFFICE, bundle.getString("officeFiles"), formatTable),
                new FormatFilterItem(FormatType.DOCUMENTS, bundle.getString("documentFiles"), formatTable),
                new FormatFilterItem(FormatType.OTHERS, bundle.getString("otherFiles"), formatTable),
                new FormatFilterItem(FormatType.CUSTOMS, bundle.getString("custom"), formatTable)
        );
    }
    private void initContextMenus() {
        MenuItem addD = new MenuItem(bundle.getString("addItem"));
        addD.setOnAction(e -> addSearchDir());
        MenuItem clearD = new MenuItem(bundle.getString("clearItems"));
        clearD.setOnAction(e -> clearSearchDirs());
        MenuItem deleteDirMenu = new MenuItem(bundle.getString("deleteItem"));
        deleteDirMenu.setDisable(true);
        deleteDirMenu.setOnAction(e -> {
            int selected = dirList.getSelectionModel().getSelectedIndex();
            if (selected >= 0) dirList.getItems().remove(selected);
        });
        dirList.setContextMenu(new ContextMenu(deleteDirMenu, addD, clearD));
        dirList.setOnContextMenuRequested(e -> {
            Node node = e.getPickResult().getIntersectedNode();
            boolean enabled = (node instanceof TextFieldListCell && ((TextFieldListCell<?>) node).getItem() != null)
                    || node instanceof Text;
            deleteDirMenu.setDisable(!enabled);
        });
        MenuItem addS = new MenuItem(bundle.getString("addItem"));
        addS.setOnAction(e -> addSearchItem());
        MenuItem clearS = new MenuItem(bundle.getString("clear"));
        clearS.setOnAction(e -> clearSearchItems());
        searchItemsList.setContextMenu(new ContextMenu(addS, clearS));
    }
    private void restoreSavedFormats(Cache cache) {
        JSONArray array = cache.getArrayCache(Cache.FORMATS_KEY);
        Set<String> savedFormats = new HashSet<>();
        for (Object obj : array) {
            savedFormats.add((String) obj);
        }
        for (FormatItem formatItem : formatTable.getAllItems())
            if (savedFormats.contains(formatItem.getExtension()))
                formatItem.getCheckBox().setSelected(true);
    }
    private void restoreLastOpenedDirs(Cache cache) {
        JSONArray lastOpens = lastOpenedDirs(cache);
        for (Object dirObj : lastOpens) {
            dirList.getItems().add(new File((String) dirObj));
        }
    }
    private void selectAllFormats() {
        for (FormatItem formatItem : formatTable.getShowingItems()) {
            formatItem.getCheckBox().setSelected(true);
        }
    }
    private void deselectAllFormats() {
        for (FormatItem formatItem : formatTable.getShowingItems()) {
            formatItem.getCheckBox().setSelected(false);
        }
    }
    private void startSearching() {
        try {
            long beginTime = System.currentTimeMillis();
            PrefSet prefSet = new PrefSet.PrefSetBuilder()
                    .caseSensitive(false)
                    .setMatchAll(matchAllRadioBtn.isSelected())
                    .searchFileName(searchFileNameBox.isSelected())
                    .searchDirName(searchDirNameBox.isSelected())
                    .caseSensitive(matchCaseBox.isSelected())
                    .matchWord(matchWordBox.isSelected())
                    .matchRegex(matchRegexBox.isSelected())
                    .setTargets(getTargets())
                    .setSearchDirs(dirList.getItems())
                    .setExtensions(getExtensions())
                    .build();
            resultTable.getItems().clear();
            setInSearchingUi();
            Searcher searcher = new Searcher(
                    prefSet,
                    resultTable.getItems(),
                    bundle,
                    fileTypeBundle,
                    formatTable.getCustomFormats());
            service = new SearchService(searcher);
            service.setOnSucceeded(e -> {
                unbindListeners();
                finishSearching(searcher.isNormalFinish());
                setTimerTexts(System.currentTimeMillis() - beginTime);
                resultTable.setPlaceholder(new Label(bundle.getString("resTablePlaceHolder")));
                System.gc();
            });
            service.setOnFailed(e -> {
                unbindListeners();
                searchingFailed();
                e.getSource().getException().printStackTrace();
                EventLogger.log(e.getSource().getException());
                resultTable.setPlaceholder(new Label(bundle.getString("resTablePlaceHolder")));
                System.gc();
            });
            Configs.addHistory(prefSet);
            resultTable.setPlaceholder(new Label(bundle.getString("isSearching")));
            service.start();
        } catch (SearchTargetNotSetException e) {
            showSearchButtonMsg("targetNotSet", searchButton);
        } catch (SearchDirNotSetException e) {
            showSearchButtonMsg("dirNotSet", searchButton);
        } catch (SearchPrefNotSetException e) {
            showSearchButtonMsg("prefNotSet", searchButton);
        }
    }
    private void setTimerTexts(long timeUsedMs) {
        timeUsedLabelText.setText(bundle.getString("timeUsed"));
        timeUsedText.setText(String.format("%.1f", (double) timeUsedMs / 1000));
        timeUnitText.setText(bundle.getString("secondUnit"));
    }
    private void finishSearching(boolean normalFinish) {
        setNotInSearchingUi(normalFinish ?
                bundle.getString("searchDone") : bundle.getString("searchAbort"));
    }
    private void searchingFailed() {
        setNotInSearchingUi(bundle.getString("searchFailed"));
    }
    private void cancelSearching() {
        searchButton.setDisable(true);
        service.getSearcher().stop();
    }
    private void setInSearchingUi() {
        isSearching = true;
        searchButton.setText(bundle.getString("cancel"));
        progressIndicator.setVisible(true);
        progressIndicator.setManaged(true);
        resultNumberText.setText("0");
        searchingStatusText.setText(bundle.getString("searching"));
        statusSuffixText.setText(bundle.getString("searchDoneSuffix"));
        timeUsedLabelText.setText("");
        timeUsedText.setText("");
        timeUnitText.setText("");
    }
    private void setNotInSearchingUi(String statusMsg) {
        isSearching = false;
        searchButton.setText(bundle.getString("search"));
        searchButton.setDisable(false);
        progressIndicator.setVisible(false);
        progressIndicator.setManaged(false);
        searchingStatusText.setText(statusMsg);
        statusSuffixText.setText(bundle.getString("searchDoneSuffix"));
    }
    private void showSearchButtonMsg(String textKey, Node parent) {
        ContextMenu popupMenu = new ContextMenu();
        MenuItem menuItem = new MenuItem(bundle.getString(textKey));
        menuItem.setDisable(true);
        popupMenu.getItems().add(menuItem);
        EventHandler<? super MouseEvent> originalHandler = parent.getOnMouseClicked();
        parent.setOnMouseClicked(e -> {
            popupMenu.show(parent, e.getScreenX(), e.getScreenY());
            parent.setOnMouseClicked(originalHandler);
        });
    }
    private void openFile(File file) {
        try {
            Desktop.getDesktop().open(file);
        } catch (IOException e) {
            e.printStackTrace();
            EventLogger.log(e);
        }
    }
    private List<String> getTargets() {
        List<String> list = new ArrayList<>();
        for (Node node : searchItemsList.getTextFields()) {
            list.add(((TextField) node).getText());
        }
        return list;
    }
    /**
     * @return the set of all selected file extensions if "search content" is selected, {@code null} otherwise.
     */
    private Set<String> getExtensions() {
        if (searchContentBox.isSelected()) {
            return formatTable.getSelectedFormats();
        } else
            return null;
    }
    private void unbindListeners() {
        service.getSearcher().resultCountProperty().removeListener(fileCountListener);
    }
    private abstract static class ResTableCallback<T> implements
            Callback<TableColumn<T, String>, TableCell<T, String>> {
        private final TableView<T> table;
        private ResTableCallback(TableView<T> table) {
            this.table = table;
        }
        protected abstract String tooltipText(T cellData);
        @Override
        public TableCell<T, String> call(TableColumn<T, String> param) {
            return new TableCell<>() {
                @Override
                protected void updateItem(String item, boolean empty) {
                    super.updateItem(item, empty);
                    if (item == null || empty) {
                        setText(null);
                    } else {
                        setText(item);
                        hoverProperty().addListener((ObservableValue<? extends Boolean> obs, Boolean wasHovered,
                                                     Boolean isNowHovered) -> {
                            if (isNowHovered && !isEmpty()) {
                                Tooltip tt = new Tooltip(tooltipText(getTableRow().getItem()));
                                tt.setShowDuration(new Duration(10000));
                                table.setTooltip(tt);
                            } else {
                                table.setTooltip(null);
                            }
                        });
                    }
                }
            };
        }
    }
    private class SearchService extends Service<Void> {
        private final Searcher searcher;
        SearchService(Searcher searcher) {
            this.searcher = searcher;
        }
        @Override
        protected Task<Void> createTask() {
            return new Task<>() {
                @Override
                protected Void call() {
                    fileCountListener = (observable, oldValue, newValue) ->
                            Platform.runLater(() ->
                                    resultNumberText.setText(Util.separateInteger(newValue.longValue())));
                    searcher.resultCountProperty().addListener(fileCountListener);
                    searcher.search();
                    return null;
                }
            };
        }
        public Searcher getSearcher() {
            return searcher;
        }
    }
}
package trashsoftware.deepSearcher2.fxml.settingsPages;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.CheckBox;
import javafx.scene.control.ComboBox;
import javafx.scene.control.Label;
import javafx.scene.control.Tooltip;
import javafx.util.Duration;
import trashsoftware.deepSearcher2.fxml.Client;
import trashsoftware.deepSearcher2.fxml.SettingsPanelController;
import trashsoftware.deepSearcher2.searcher.Algorithm;
import trashsoftware.deepSearcher2.util.Configs;
import java.io.IOException;
public class AdvancedSearchingPage extends SettingsPage {
    @FXML
    ComboBox<Algorithm.Regular> algorithmBox;
    @FXML
    ComboBox<Algorithm.Word> wordAlgorithmBox;
    @FXML
    ComboBox<Algorithm.Regex> regexAlgorithmBox;
    @FXML
    ComboBox<Integer> cpuThreadsBox;
    @FXML
    ComboBox<TraversalOrder> traversalOrderBox;
    @FXML
    CheckBox wholeContentBox;
    @FXML
    CheckBox escapeBox;
    @FXML
    Label wholeContentHelp;
    @FXML
    Label escapeHelp;
    public AdvancedSearchingPage(SettingsPanelController controller) throws IOException {
        super(controller);
        FXMLLoader loader = new FXMLLoader(getClass()
                .getResource("/trashsoftware/deepSearcher2/fxml/settingsPages/advancedSearching.fxml"),
                Client.getBundle());
        loader.setRoot(this);
        loader.setController(this);
        loader.load();
        controller.addControls(algorithmBox, wordAlgorithmBox, regexAlgorithmBox, cpuThreadsBox, traversalOrderBox,
                wholeContentBox, escapeBox);
        initAlgorithmBoxes();
        initCheckBoxes();
        initThreadsBox();
        initTraversalOrderBox();
    }
    @Override
    public void saveChanges() {
        if (getStatusSaver().hasChanged(algorithmBox)) {
            Configs.getConfigs().writeConfig("alg",
                    algorithmBox.getSelectionModel().getSelectedItem().name());
            getStatusSaver().store(algorithmBox);
        }
        if (getStatusSaver().hasChanged(wordAlgorithmBox)) {
            Configs.getConfigs().writeConfig("wordAlg",
                    wordAlgorithmBox.getSelectionModel().getSelectedItem().name());
            getStatusSaver().store(wordAlgorithmBox);
        }
        if (getStatusSaver().hasChanged(regexAlgorithmBox)) {
            Configs.getConfigs().writeConfig("regexAlg",
                    regexAlgorithmBox.getSelectionModel().getSelectedItem().name());
            getStatusSaver().store(regexAlgorithmBox);
        }
        if (getStatusSaver().hasChanged(wholeContentBox)) {
            Configs.getConfigs().writeConfig("wholeContent", String.valueOf(wholeContentBox.isSelected()));
            getStatusSaver().store(wholeContentBox);
        }
        if (getStatusSaver().hasChanged(escapeBox)) {
            Configs.getConfigs().writeConfig("escapes", String.valueOf(escapeBox.isSelected()));
            getStatusSaver().store(escapeBox);
        }
        if (getStatusSaver().hasChanged(cpuThreadsBox)) {
            Configs.getConfigs().writeConfig("cpuThreads", String.valueOf(cpuThreadsBox.getSelectionModel().getSelectedItem()));
            getStatusSaver().store(cpuThreadsBox);
        }
        if (getStatusSaver().hasChanged(traversalOrderBox)) {
            Configs.getConfigs().setDepthFirst(traversalOrderBox.getSelectionModel().getSelectedItem() == TraversalOrder.DEPTH_FIRST);
            getStatusSaver().store(traversalOrderBox);
        }
    }
    private void initThreadsBox() {
        int curThreadNum = Configs.getConfigs().getCurrentCpuThreads();
        int maxThreadLimit = Runtime.getRuntime().availableProcessors();
        if (curThreadNum > maxThreadLimit) curThreadNum = maxThreadLimit;
        for (int i = 1; i <= maxThreadLimit; i++) {
            cpuThreadsBox.getItems().add(i);
        }
        cpuThreadsBox.getSelectionModel().select(Integer.valueOf(curThreadNum));
        getStatusSaver().store(cpuThreadsBox);
    }
    private void initTraversalOrderBox() {
        traversalOrderBox.getItems().addAll(TraversalOrder.DEPTH_FIRST, TraversalOrder.BREADTH_FIRST);
        traversalOrderBox.getSelectionModel().select(Configs.getConfigs().isDepthFirst() ? 0 : 1);
        getStatusSaver().store(traversalOrderBox);
    }
    private void initCheckBoxes() {
        wholeContentBox.selectedProperty().addListener(((observable, oldValue, newValue) ->
                escapeBox.setDisable(!newValue)));
        escapeBox.setSelected(Configs.getConfigs().isSearchEscapes());
        wholeContentBox.setSelected(Configs.getConfigs().isWholeContent());
        getStatusSaver().store(wholeContentBox);
        getStatusSaver().store(escapeBox);
        Tooltip wholeTt = new Tooltip(Client.getBundle().getString("contentAsWholeHelp"));
        wholeTt.setWrapText(true);
        wholeTt.setShowDuration(new Duration(10000));
        Tooltip.install(wholeContentHelp, wholeTt);
        Tooltip escapeTt = new Tooltip(Client.getBundle().getString("escapesHelp"));
        escapeTt.setWrapText(true);
        escapeTt.setShowDuration(new Duration(10000));
        Tooltip.install(escapeHelp, escapeTt);
    }
    private void initAlgorithmBoxes() {
        setAlgorithmBox(algorithmBox, Configs.getConfigs().getCurrentSearchingAlgorithm(),
                Algorithm.Regular.AUTO,
                Algorithm.Regular.NATIVE,
                Algorithm.Regular.NAIVE,
                Algorithm.Regular.KMP,
                Algorithm.Regular.SUNDAY
        );
        setAlgorithmBox(wordAlgorithmBox, Configs.getConfigs().getCurrentWordSearchingAlgorithm(),
                Algorithm.Word.NAIVE,
                Algorithm.Word.HASH
        );
        setAlgorithmBox(regexAlgorithmBox, Configs.getConfigs().getCurrentRegexSearchingAlgorithm(),
                Algorithm.Regex.NATIVE
        );
    }
    @SafeVarargs
    private <T extends Algorithm> void setAlgorithmBox(ComboBox<T> algorithmBox,
                                                       T currentAlg,
                                                       T... algorithms) {
        algorithmBox.getItems().addAll(algorithms);
        algorithmBox.getSelectionModel().select(currentAlg);
        getStatusSaver().store(algorithmBox);
    }
    private enum TraversalOrder {
        DEPTH_FIRST("depthFirst"),
        BREADTH_FIRST("breadthFirst");
        private final String nameKey;
        TraversalOrder(String nameKey) {
            this.nameKey = nameKey;
        }
        @Override
        public String toString() {
            return Client.getBundle().getString(nameKey);
        }
    }
}
package trashsoftware.deepSearcher2.fxml.settingsPages;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.Button;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableView;
import javafx.scene.control.cell.PropertyValueFactory;
import trashsoftware.deepSearcher2.fxml.Client;
import trashsoftware.deepSearcher2.fxml.SettingsPanelController;
import trashsoftware.deepSearcher2.fxml.widgets.FormatInputBox;
import trashsoftware.deepSearcher2.util.Configs;
import java.io.IOException;
import java.util.Map;
public class CustomPage extends SettingsPage implements FormatInputAble {
    @FXML
    TableView<FmtItem> customFmtTable;
    @FXML
    Button deleteFmtButton;
    public CustomPage(SettingsPanelController controller) throws IOException {
        super(controller);
        FXMLLoader loader = new FXMLLoader(getClass()
                .getResource("/trashsoftware/deepSearcher2/fxml/settingsPages/custom.fxml"),
                Client.getBundle());
        loader.setRoot(this);
        loader.setController(this);
        loader.load();
        setFmtTableFactory();
        refreshTable();
    }
    @Override
    public void saveChanges() {
    }
    @FXML
    void addFmt() throws IOException {
        FormatInputBox.showInputBox(
                this,
                getController().getStage(),
                Client.getBundle().getString("customTextFormats"),
                true);
    }
    @FXML
    void deleteFmt() {
        int index = customFmtTable.getSelectionModel().getSelectedIndex();
        String removedExt = customFmtTable.getItems().remove(index).ext.substring(1);  // also remove the dot
        Configs.getConfigs().removeCustomFormat(removedExt);
        refreshTable();
        getController().getMainView().refreshFormatTable();
    }
    @Override
    public void addFormat(String ext, String description) {
        String pureExt;
        if (ext.startsWith(".")) {
            pureExt = ext.substring(1);
        } else {
            pureExt = ext;
        }
        String realDes;
        if (description.strip().length() == 0) {
            realDes = pureExt.toUpperCase() + " " + Client.getBundle().getString("file");
        } else {
            realDes = description;
        }
        Configs.getConfigs().addCustomFormat(pureExt, realDes);
        refreshTable();
        getController().getMainView().refreshFormatTable();
    }
    private void refreshTable() {
        customFmtTable.getItems().clear();
        Map<String, String> dirs = Configs.getConfigs().getAllCustomFormats();
        for (Map.Entry<String, String> extDes : dirs.entrySet()) {
            customFmtTable.getItems().add(new FmtItem("." + extDes.getKey(), extDes.getValue()));
        }
    }
    private void setFmtTableFactory() {
        TableColumn<FmtItem, ?> desCol = customFmtTable.getColumns().get(0);
        TableColumn<FmtItem, ?> extCol = customFmtTable.getColumns().get(1);
        desCol.setCellValueFactory(new PropertyValueFactory<>("description"));
        extCol.setCellValueFactory(new PropertyValueFactory<>("ext"));
        customFmtTable.getSelectionModel().selectedIndexProperty().addListener(((observableValue, number, t1) ->
                deleteFmtButton.setDisable(t1.intValue() == -1)));
    }
    public static class FmtItem {
        private final String description;
        private final String ext;  // with dot
        private FmtItem(String ext, String description) {
            this.ext = ext;
            this.description = description;
        }
        @FXML
        public String getDescription() {
            return description;
        }
        @FXML
        public String getExt() {
            return ext;
        }
    }
}
package trashsoftware.deepSearcher2.fxml.settingsPages;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.Button;
import javafx.scene.control.ListView;
import javafx.stage.DirectoryChooser;
import trashsoftware.deepSearcher2.fxml.Client;
import trashsoftware.deepSearcher2.fxml.SettingsPanelController;
import trashsoftware.deepSearcher2.fxml.widgets.FormatInputBox;
import trashsoftware.deepSearcher2.util.Configs;
import java.io.File;
import java.io.IOException;
import java.util.Set;
public class ExclusionPage extends SettingsPage implements FormatInputAble {
    @FXML
    ListView<String> excludedDirList, excludedFormatList;
    @FXML
    Button deleteDirButton, deleteFormatButton;
    public ExclusionPage(SettingsPanelController controller) throws IOException {
        super(controller);
        FXMLLoader loader = new FXMLLoader(getClass()
                .getResource("/trashsoftware/deepSearcher2/fxml/settingsPages/exclusion.fxml"),
                Client.getBundle());
        loader.setRoot(this);
        loader.setController(this);
        loader.load();
        addDirListListener();
        addFormatListListener();
        refreshDirList();
        refreshFormatsList();
    }
    private void addDirListListener() {
        excludedDirList.getSelectionModel().selectedIndexProperty().addListener(((observableValue, number, t1) ->
                deleteDirButton.setDisable(t1.intValue() == -1)));
    }
    private void addFormatListListener() {
        excludedFormatList.getSelectionModel().selectedIndexProperty().addListener(((observableValue, number, t1) ->
                deleteFormatButton.setDisable(t1.intValue() == -1)));
    }
    @Override
    public void saveChanges() {
    }
    @FXML
    void addExcludedDir() {
        File file = new DirectoryChooser().showDialog(getController().getStage());
        if (file != null) {
            Configs.getConfigs().addExcludedDir(file.getAbsolutePath());
            refreshDirList();
        }
    }
    @FXML
    void deleteExcludedDir() {
        int index = excludedDirList.getSelectionModel().getSelectedIndex();
        String removed = excludedDirList.getItems().remove(index);
        Configs.getConfigs().removeExcludedDir(removed);
        refreshDirList();
    }
    @FXML
    void addExcludedFormat() throws IOException {
        FormatInputBox.showInputBox(
                this,
                getController().getStage(),
                Client.getBundle().getString("excludedFormats"),
                false);
    }
    @FXML
    void deleteExcludedFormat() {
        int index = excludedFormatList.getSelectionModel().getSelectedIndex();
        String removed = excludedFormatList.getItems().remove(index).substring(1);  // also remove the dot
        Configs.getConfigs().removeExcludedFormat(removed);
        refreshFormatsList();
    }
    @Override
    public void addFormat(String extension, String description) {
        String pureExt;
        if (extension.startsWith(".")) {
            pureExt = extension.substring(1);
        } else {
            pureExt = extension;
        }
        Configs.getConfigs().addExcludedFormat(pureExt);
        refreshFormatsList();
    }
    private void refreshDirList() {
        excludedDirList.getItems().clear();
        Set<String> dirs = Configs.getConfigs().getAllExcludedDirs();
        excludedDirList.getItems().addAll(dirs);
    }
    private void refreshFormatsList() {
        excludedFormatList.getItems().clear();
        Set<String> formats = Configs.getConfigs().getAllExcludedFormats();
        for (String f : formats) {
            excludedFormatList.getItems().add("." + f);
        }
    }
}
package trashsoftware.deepSearcher2.fxml.settingsPages;
/**
 * An interface that supports the {@code FormatInputBox} to input a format.
 */
public interface FormatInputAble {
    /**
     * Adds a format to this, from a {@code FormatInputBox}.
     *
     * @param ext         the extension of the format
     * @param description description of format
     */
    void addFormat(String ext, String description);
}
package trashsoftware.deepSearcher2.fxml.settingsPages;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.CheckBox;
import javafx.scene.control.ComboBox;
import javafx.scene.text.Font;
import trashsoftware.deepSearcher2.fxml.Client;
import trashsoftware.deepSearcher2.fxml.ConfirmBox;
import trashsoftware.deepSearcher2.fxml.SettingsPanelController;
import trashsoftware.deepSearcher2.util.Configs;
import trashsoftware.deepSearcher2.util.NamedLocale;
import java.io.IOException;
import java.util.List;
public class GeneralPage extends SettingsPage {
    @FXML
    ComboBox<Integer> fontSizeBox;
    @FXML
    ComboBox<String> fontBox;
    @FXML
    ComboBox<NamedLocale> languageBox;
    @FXML
    CheckBox useCustomFontBox;
    public GeneralPage(SettingsPanelController controller) throws IOException {
        super(controller);
        FXMLLoader loader = new FXMLLoader(getClass()
                .getResource("/trashsoftware/deepSearcher2/fxml/settingsPages/general.fxml"),
                Client.getBundle());
        loader.setRoot(this);
        loader.setController(this);
        loader.load();
        controller.addControls(languageBox, fontSizeBox, languageBox, useCustomFontBox, fontBox);
        initLanguageBox();
        initUseCusFontBox();
        initFontBoxes();
    }
    @Override
    public void saveChanges() {
        if (getStatusSaver().hasChanged(languageBox)) {
            NamedLocale selectedLocale = languageBox.getSelectionModel().getSelectedItem();
            Configs.getConfigs().writeConfig("locale", selectedLocale.getConfigValue());
            getStatusSaver().store(languageBox);
            askRestart();
        }
        if (getStatusSaver().hasChanged(useCustomFontBox) ||
                getStatusSaver().hasChanged(fontBox) ||
                getStatusSaver().hasChanged(fontSizeBox)) {
            Configs.getConfigs().setUseCustomFont(
                    useCustomFontBox.isSelected(),
                    fontBox.getSelectionModel().getSelectedItem(),
                    fontSizeBox.getSelectionModel().getSelectedItem());
            getStatusSaver().store(useCustomFontBox);
            getStatusSaver().store(fontBox);
            getStatusSaver().store(fontSizeBox);
            askRestart();
        }
    }
    private void askRestart() {
        ConfirmBox confirmBox = ConfirmBox.createConfirmBox(getController().getStage());
        confirmBox.setMessage(Client.getBundle().getString("operationApplyAfterRestart"));
        confirmBox.setOnConfirmed(() -> {
            getController().getStage().close();
            Client.restartClient();
        });
        confirmBox.show();
    }
    private void initLanguageBox() {
        List<NamedLocale> localeList = Configs.getAllLocales();
        for (NamedLocale locale : localeList) {
            languageBox.getItems().add(locale);
            if (Client.getBundle().getLocale().equals(locale.getLocale())) {
                languageBox.getSelectionModel().selectLast();
            }
        }
        getStatusSaver().store(languageBox);
    }
    private void initUseCusFontBox() {
        useCustomFontBox.selectedProperty().addListener(((observable, oldValue, newValue) -> {
            if (newValue) {
                fontBox.setDisable(false);
                fontSizeBox.setDisable(false);
            } else {
                fontBox.setDisable(true);
                fontSizeBox.setDisable(true);
            }
        }));
        useCustomFontBox.setSelected(Configs.getConfigs().isUseCustomFont());
        getStatusSaver().store(useCustomFontBox);
    }
    private void initFontBoxes() {
        for (String font : Font.getFamilies()) {
            fontBox.getItems().add(font);
        }
        fontBox.getSelectionModel().select(Configs.getConfigs().getCustomFont());
        if (fontBox.getSelectionModel().getSelectedIndex() == -1) {
            fontBox.getSelectionModel().select(Font.getDefault().getFamily());
        }
        getStatusSaver().store(fontBox);
        fontSizeBox.getItems().addAll(8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36);
        fontSizeBox.getSelectionModel().select(Integer.valueOf(Configs.getConfigs().getFontSize(12)));
        getStatusSaver().store(fontSizeBox);
    }
}
package trashsoftware.deepSearcher2.fxml.settingsPages;
import trashsoftware.deepSearcher2.fxml.SettingsPanelController;
public class NavigatorPage extends Page {
    public NavigatorPage(SettingsPanelController controller) {
        super(controller);
    }
}
package trashsoftware.deepSearcher2.fxml.settingsPages;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import trashsoftware.deepSearcher2.fxml.Client;
import trashsoftware.deepSearcher2.fxml.ConfirmBox;
import trashsoftware.deepSearcher2.fxml.SettingsPanelController;
import trashsoftware.deepSearcher2.util.Cache;
import trashsoftware.deepSearcher2.util.Configs;
import java.io.IOException;
public class OthersPage extends SettingsPage {
    public OthersPage(SettingsPanelController controller) throws IOException {
        super(controller);
        FXMLLoader loader = new FXMLLoader(getClass()
                .getResource("/trashsoftware/deepSearcher2/fxml/settingsPages/others.fxml"),
                Client.getBundle());
        loader.setRoot(this);
        loader.setController(this);
        loader.load();
    }
    @Override
    public void saveChanges() {
    }
    private void showConfirm(String msg, String confirmButtonText, Runnable onConfirm) {
        ConfirmBox confirmBox = ConfirmBox.createConfirmBox(getController().getStage());
        confirmBox.setConfirmButtonText(confirmButtonText);
        confirmBox.setMessage(msg);
        confirmBox.setOnConfirmed(onConfirm);
        confirmBox.show();
    }
    @FXML
    void clearHistory() {
        showConfirm(Client.getBundle().getString("confirmClearHistory"),
                Client.getBundle().getString("clear"),
                Configs::clearAllHistory);
    }
    @FXML
    void restoreSettings() {
        showConfirm(Client.getBundle().getString("confirmRestoreSettings") +
                        "\n" + Client.getBundle().getString("needRestart"),
                Client.getBundle().getString("clear"),
                Configs.getConfigs()::clearSettings);
    }
    @FXML
    void clearAllData() {
        showConfirm(Client.getBundle().getString("confirmClearData") +
                        "\n" + Client.getBundle().getString("needRestart"),
                Client.getBundle().getString("clear"),
                Configs.getConfigs()::clearAllData);
    }
    @FXML
    void clearCache() {
        Cache.clearCache();
    }
}
package trashsoftware.deepSearcher2.fxml.settingsPages;
import javafx.scene.layout.VBox;
import trashsoftware.deepSearcher2.fxml.SettingsPanelController;
/**
 * A page that can be shown inside the right panel of the settings panel.
 */
public abstract class Page extends VBox {
    private final SettingsPanelController controller;
    public Page(SettingsPanelController controller) {
        this.controller = controller;
    }
    protected SettingsPanelController getController() {
        return controller;
    }
}
package trashsoftware.deepSearcher2.fxml.settingsPages;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.CheckBox;
import javafx.scene.control.TextField;
import trashsoftware.deepSearcher2.fxml.Client;
import trashsoftware.deepSearcher2.fxml.SettingsPanelController;
import trashsoftware.deepSearcher2.util.Configs;
import java.io.IOException;
public class SearchingOptionsPage extends SettingsPage {
    @FXML
    CheckBox includePathNameBox;
    @FXML
    CheckBox shownHiddenBox;
    @FXML
    CheckBox limitDepthBox;
    @FXML
    TextField searchDepthField;
    public SearchingOptionsPage(SettingsPanelController controller) throws IOException {
        super(controller);
        FXMLLoader loader = new FXMLLoader(getClass()
                .getResource("/trashsoftware/deepSearcher2/fxml/settingsPages/searchingOptions.fxml"),
                Client.getBundle());
        loader.setRoot(this);
        loader.setController(this);
        loader.load();
        controller.addControls(includePathNameBox, shownHiddenBox, limitDepthBox, searchDepthField);
        initCheckBoxes();
        initMaxDepthBox();
    }
    @Override
    public void saveChanges() {
        if (getStatusSaver().hasChanged(includePathNameBox)) {
            Configs.getConfigs().setIncludePathName(includePathNameBox.isSelected());
            getStatusSaver().store(includePathNameBox);
        }
        if (getStatusSaver().hasChanged(shownHiddenBox)) {
            Configs.getConfigs().setShowHidden(shownHiddenBox.isSelected());
            getStatusSaver().store(shownHiddenBox);
        }
        if (getStatusSaver().hasChanged(limitDepthBox)) {
            Configs.getConfigs().setLimitDepth(limitDepthBox.isSelected());
            getStatusSaver().store(limitDepthBox);
        }
        if (limitDepthBox.isSelected()) {
            try {
                Configs.getConfigs().setMaxSearchDepth(Integer.parseInt(searchDepthField.getText()));
            } catch (NumberFormatException e) {
                e.printStackTrace();
            }
            getStatusSaver().store(searchDepthField);
        }
    }
    private void initCheckBoxes() {
        includePathNameBox.setSelected(Configs.getConfigs().isIncludePathName());
        shownHiddenBox.setSelected(Configs.getConfigs().isShowHidden());
        getStatusSaver().store(includePathNameBox);
        getStatusSaver().store(shownHiddenBox);
    }
    private void initMaxDepthBox() {
        limitDepthBox.selectedProperty().addListener(((observable, oldValue, newValue) ->
                searchDepthField.setDisable(!newValue)));
        searchDepthField.textProperty().addListener(((observable, oldValue, newValue) -> {
            if (newValue.length() > 0) {
                try {
                    int r = Integer.parseInt(newValue);
                    if (r > 0) {
                        searchDepthField.setText(newValue);
                    } else {
                        searchDepthField.setText(oldValue);
                    }
                } catch (NumberFormatException e) {
                    searchDepthField.setText(oldValue);
                }
            }
        }));
        searchDepthField.setText(String.valueOf(Configs.getConfigs().getMaxSearchDepth()));
        limitDepthBox.setSelected(Configs.getConfigs().isLimitDepth());
        getStatusSaver().store(limitDepthBox);
        getStatusSaver().store(searchDepthField);
    }
}
package trashsoftware.deepSearcher2.fxml.settingsPages;
import javafx.scene.control.*;
import trashsoftware.deepSearcher2.fxml.SettingsPanelController;
import java.util.ArrayList;
import java.util.List;
/**
 * A page that has real setting items.
 */
public abstract class SettingsPage extends Page {
    public SettingsPage(SettingsPanelController controller) {
        super(controller);
    }
    /**
     * Saves all stated changes to configuration file.
     */
    public abstract void saveChanges();
    /**
     * @return the status saver of the whole setting panel.
     */
    protected StatusSaver getStatusSaver() {
        return getController().getStatusSaver();
    }
}
package trashsoftware.deepSearcher2.fxml.settingsPages;
import javafx.scene.control.CheckBox;
import javafx.scene.control.ComboBox;
import javafx.scene.control.TextField;
import java.util.HashMap;
import java.util.Map;
/**
 * A class that stores the dynamic selection status of any added controls.
 */
public class StatusSaver {
    private final Map<Integer, Integer> comboBoxesIndexStatus = new HashMap<>();
    private final Map<Integer, Boolean> checkBoxesStatus = new HashMap<>();
    private final Map<Integer, String> textFieldStatus = new HashMap<>();
    /**
     * Stores the current selection status of a {@code ComboBox}
     *
     * @param comboBox the box
     */
    public void store(ComboBox<?> comboBox) {
        comboBoxesIndexStatus.put(System.identityHashCode(comboBox), comboBox.getSelectionModel().getSelectedIndex());
    }
    /**
     * Stores the current selection status of a {@code CheckBox}
     *
     * @param checkBox the box
     */
    public void store(CheckBox checkBox) {
        checkBoxesStatus.put(System.identityHashCode(checkBox), checkBox.isSelected());
    }
    /**
     * Stores the current text of a {@code TextField}
     *
     * @param textField the text field
     */
    public void store(TextField textField) {
        textFieldStatus.put(System.identityHashCode(textField), textField.getText());
    }
    /**
     * Returns whether a {@code ComboBox} has changed its selection status compared to the last stored value.
     *
     * @param comboBox the box
     * @return {@code true} if the box has changed its status
     */
    public boolean hasChanged(ComboBox<?> comboBox) {
        Integer storedIndex = comboBoxesIndexStatus.get(System.identityHashCode(comboBox));
        if (storedIndex == null) throw new RuntimeException("Status of ComboBox Not Saved");
        return storedIndex != comboBox.getSelectionModel().getSelectedIndex();
    }
    /**
     * Returns whether a {@code CheckBox} has changed its selection status compared to the last stored value.
     *
     * @param checkBox the box
     * @return {@code true} if the box has changed its status
     */
    public boolean hasChanged(CheckBox checkBox) {
        Boolean storedBoolean = checkBoxesStatus.get(System.identityHashCode(checkBox));
        if (storedBoolean == null) throw new RuntimeException("Status of CheckBox Not Saved");
        return storedBoolean != checkBox.isSelected();
    }
    /**
     * Returns whether a {@code TextField} has changed its text compared to the last stored value.
     *
     * @param textField the text field
     * @return {@code true} if the text field has changed its status
     */
    public boolean hasChanged(TextField textField) {
        String storedValue = textFieldStatus.get(System.identityHashCode(textField));
        if (storedValue == null) throw new RuntimeException("Status of TextField Not Saved");
        return !textField.getText().equals(storedValue);
    }
}
package trashsoftware.deepSearcher2.fxml;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.*;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;
import trashsoftware.deepSearcher2.fxml.settingsPages.*;
import trashsoftware.deepSearcher2.guiItems.SettingsItem;
import trashsoftware.deepSearcher2.util.EventLogger;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.ResourceBundle;
public class SettingsPanelController implements Initializable {
    private final StatusSaver statusSaver = new StatusSaver();
    private final List<ComboBox<?>> comboBoxes = new ArrayList<>();
    private final List<CheckBox> checkBoxes = new ArrayList<>();
    private final List<TextField> textFields = new ArrayList<>();
    @FXML
    TreeView<SettingsItem> treeView;
    @FXML
    ScrollPane contentPane;
    @FXML
    Button okButton, cancelButton, applyButton;
    private Stage thisStage;
    private MainViewController mainView;
    private ResourceBundle bundle;
    @Override
    public void initialize(URL url, ResourceBundle resourceBundle) {
        bundle = resourceBundle;
        setTreeViewListener();
        setUpItems();
        contentPane.setFitToWidth(true);
    }
    void setStage(Stage stage, MainViewController mainView) {
        this.thisStage = stage;
        this.mainView = mainView;
    }
    public Stage getStage() {
        return thisStage;
    }
    public MainViewController getMainView() {
        return mainView;
    }
    /**
     * @return the status saver of the whole settings panel.
     */
    public StatusSaver getStatusSaver() {
        return statusSaver;
    }
    /**
     * Adds all controllable {@code Control}'s that need to be monitored for changes to page.
     * <p>
     * This method should be called just after {@code FXMLLoader.load} in the constructor of any sub-classes of this.
     *
     * @param controls array of controllable {@code Control}'s
     */
    public void addControls(Control... controls) {
        for (Control control : controls) {
            if (control instanceof ComboBox) comboBoxes.add((ComboBox<?>) control);
            else if (control instanceof CheckBox) checkBoxes.add((CheckBox) control);
            else if (control instanceof TextField) textFields.add((TextField) control);
            else throw new RuntimeException("Unrecognizable Control");
        }
    }
    /**
     * Expands the left tree view until a specific page
     *
     * @param targetPage the target page
     */
    public void expandUntil(Class<? extends Page> targetPage) {
        expandUntil(targetPage, treeView.getRoot());
    }
    private boolean expandUntil(Class<? extends Page> targetPage, TreeItem<SettingsItem> item) {
        if (item.getValue().getPage().getClass() == targetPage) {
            treeView.getSelectionModel().select(item);
            return true;
        }
        for (TreeItem<SettingsItem> child : item.getChildren()) {
            if (expandUntil(targetPage, child)) {
                item.setExpanded(true);
            }
        }
        return false;
    }
    @FXML
    void cancelAction() {
        closeWindow();
    }
    @FXML
    void applyAction() {
        applyAllChanges(treeView.getRoot());
        applyButton.setDisable(true);
    }
    @FXML
    void okAction() {
        applyAllChanges(treeView.getRoot());
        closeWindow();
    }
    private void applyAllChanges(TreeItem<SettingsItem> item) {
        Page page = item.getValue().getPage();
        if (page instanceof SettingsPage) {
            ((SettingsPage) page).saveChanges();
        }
        for (TreeItem<SettingsItem> child : item.getChildren()) {
            applyAllChanges(child);
        }
    }
    private void closeWindow() {
        thisStage.close();
    }
    private void setUpItems() {
        TreeItem<SettingsItem> root = new TreeItem<>();
        try {
            NavigatorPage mainPage = new NavigatorPage(this);
            root.setValue(new SettingsItem(bundle.getString("settings"), mainPage));
            GeneralPage generalPage = new GeneralPage(this);
            root.getChildren().add(new TreeItem<>(
                    new SettingsItem(bundle.getString("general"), generalPage)));
            TreeItem<SettingsItem> searchingRoot = new TreeItem<>();
            NavigatorPage searchingMainPage = new NavigatorPage(this);
            searchingRoot.setValue(new SettingsItem(bundle.getString("searchSettings"), searchingMainPage));
            root.getChildren().add(searchingRoot);
            SearchingOptionsPage searchingOptionsPage = new SearchingOptionsPage(this);
            searchingRoot.getChildren().add(new TreeItem<>(
                    new SettingsItem(bundle.getString("searchingOptions"), searchingOptionsPage)
            ));
            ExclusionPage exclusionPage = new ExclusionPage(this);
            searchingRoot.getChildren().add(new TreeItem<>(
                    new SettingsItem(bundle.getString("exclusions"), exclusionPage)
            ));
            CustomPage customPage = new CustomPage(this);
            searchingRoot.getChildren().add(new TreeItem<>(
                    new SettingsItem(bundle.getString("custom"), customPage)
            ));
            AdvancedSearchingPage advancedSearchingPage = new AdvancedSearchingPage(this);
            searchingRoot.getChildren().add(new TreeItem<>(
                    new SettingsItem(bundle.getString("advancedSearching"), advancedSearchingPage)));
            searchingRoot.setExpanded(true);
            OthersPage othersPage = new OthersPage(this);
            root.getChildren().add(new TreeItem<>(
                    new SettingsItem(bundle.getString("others"), othersPage)));
        } catch (IOException ioe) {
            ioe.printStackTrace();
            EventLogger.log(ioe);
        }
        setApplyButtonStatusChanger();
        root.setExpanded(true);
        treeView.setRoot(root);
    }
    private void setTreeViewListener() {
        treeView.getSelectionModel().selectedItemProperty()
                .addListener((observableValue, settingsItemTreeItem, t1) -> {
                    Page page = t1.getValue().getPage();
                    if (page instanceof SettingsPage) {
                        showPage((SettingsPage) page);
                    } else if (page instanceof NavigatorPage) {
                        showNavigatorPage(t1);
                    }
                });
    }
    private void showNavigatorPage(TreeItem<SettingsItem> t1) {
        VBox root = new VBox();
        for (TreeItem<SettingsItem> treeItem : t1.getChildren()) {
            Hyperlink link = new Hyperlink(treeItem.getValue().toString());
            link.setOnAction(e -> treeView.getSelectionModel().select(treeItem));
            root.getChildren().add(link);
        }
        contentPane.setContent(root);
    }
    private void showPage(SettingsPage settingsPage) {
        contentPane.setContent(settingsPage);
    }
    /**
     * Sets the enable/disable status listener of apply button.
     * <p>
     * The apply button should be enabled when any managed controls have changed their selection.
     */
    private void setApplyButtonStatusChanger() {
        for (ComboBox<?> comboBox : comboBoxes) {
            comboBox.getSelectionModel().selectedIndexProperty().addListener(((observableValue, number, t1) ->
                    applyButton.setDisable(noStatusChanged())));
        }
        for (CheckBox checkBox : checkBoxes) {
            checkBox.selectedProperty().addListener(((observableValue, aBoolean, t1) ->
                    applyButton.setDisable(noStatusChanged())));
        }
        for (TextField textField : textFields) {
            textField.textProperty().addListener(((observableValue, aBoolean, t1) ->
                    applyButton.setDisable(noStatusChanged())));
        }
        // do not set textfield listeners
    }
    private boolean noStatusChanged() {
        for (ComboBox<?> comboBox : comboBoxes)
            if (statusSaver.hasChanged(comboBox)) return false;
        for (CheckBox checkBox : checkBoxes)
            if (statusSaver.hasChanged(checkBox)) return false;
        for (TextField textField : textFields)
            if (statusSaver.hasChanged(textField)) return false;
        return true;
    }
}
package trashsoftware.deepSearcher2.fxml.widgets;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.layout.RowConstraints;
import javafx.stage.Modality;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.stage.Window;
import trashsoftware.deepSearcher2.fxml.Client;
import trashsoftware.deepSearcher2.fxml.settingsPages.FormatInputAble;
import java.io.IOException;
import java.net.URL;
import java.util.ResourceBundle;
public class FormatInputBox implements Initializable {
    @FXML
    RowConstraints descriptionRow;
    @FXML
    TextField descriptionField;
    @FXML
    TextField extField;
    @FXML
    Label descriptionLabel;
    private FormatInputAble parent;
    private Stage stage;
    public static void showInputBox(FormatInputAble parent, Window ownerWindow, String title, boolean hasDescription)
            throws IOException {
        FXMLLoader loader = new FXMLLoader(
                FormatInputBox.class.getResource("/trashsoftware/deepSearcher2/fxml/widgets/formatInputBox.fxml"),
                Client.getBundle());
        Parent root = loader.load();
        Stage stage = new Stage();
        stage.setTitle(title);
        stage.initOwner(ownerWindow);
        stage.initModality(Modality.WINDOW_MODAL);
        stage.initStyle(StageStyle.UTILITY);
        stage.setScene(new Scene(root));
        FormatInputBox fib = loader.getController();
        fib.setParentAndStage(parent, stage, hasDescription);
        stage.show();
    }
    @Override
    public void initialize(URL url, ResourceBundle resourceBundle) {
    }
    @FXML
    void okAction() {
        String ext = extField.getText();
        String des = descriptionField.getText();
        if (ext.length() > 0) {
            parent.addFormat(ext, des);
            stage.close();
        } else {
            // TODO: alert
        }
    }
    @FXML
    void cancelAction() {
        stage.close();
    }
    private void setParentAndStage(FormatInputAble parent, Stage stage, boolean hasDescription) {
        this.parent = parent;
        this.stage = stage;
        if (!hasDescription) {
            descriptionRow.setMaxHeight(0);
            descriptionField.setVisible(false);
            descriptionLabel.setVisible(false);
        }
    }
}
package trashsoftware.deepSearcher2.fxml.widgets;
import javafx.scene.control.TableView;
import trashsoftware.deepSearcher2.guiItems.FormatFilterItem;
import trashsoftware.deepSearcher2.guiItems.FormatItem;
import trashsoftware.deepSearcher2.guiItems.FormatType;
import trashsoftware.deepSearcher2.util.Util;
import java.util.*;
public class FormatTable extends TableView<FormatItem> {
    public static final Set<String> TEXT_FMTS = Set.of(
            "txt", "log"
    );
    public static final Set<String> CODE_FMTS = Set.of(
            "c", "cpp", "h", "java", "js", "py", "r"
    );
    public static final Set<String> MS_OFFICE_FMTS = Set.of(
            "doc", "docx", "ppt", "pptx", "xls", "xlsx"
    );
    public static final Set<String> DOCUMENT_FMTS = Set.of(
            "pdf", "rmd", "tex"
    );
    public static final Map<FormatType, Set<String>> FMT_MAP = Map.of(
            FormatType.TEXT, TEXT_FMTS,
            FormatType.CODES, CODE_FMTS,
            FormatType.MS_OFFICE, MS_OFFICE_FMTS,
            FormatType.DOCUMENTS, DOCUMENT_FMTS
    );
    private static final Set<String> BUILTIN_FORMATS =
            Util.mergeSets(TEXT_FMTS, CODE_FMTS, MS_OFFICE_FMTS, DOCUMENT_FMTS);
    private final Set<String> knownFormats = new HashSet<>();
    private final List<FormatItem> allItems = new ArrayList<>();
    private Map<String, String> customFormats;
    public FormatTable() {
        initialize();
    }
    /**
     * Adds a format.
     *
     * @param formatItem the format to be added
     */
    public void addItem(FormatItem formatItem) {
        allItems.add(formatItem);
    }
    /**
     * Restore all status to the initial status
     */
    public void initialize() {
        allItems.clear();
        getItems().clear();
        if (customFormats != null) customFormats.clear();
        knownFormats.clear();
        knownFormats.addAll(BUILTIN_FORMATS);
    }
    /**
     * Applies a filter and using this filter to display formats.
     *
     * @param filterItem the filter
     */
    public void setFilter(FormatFilterItem filterItem) {
        getItems().clear();
        List<FormatItem> filtered = filterItem.filter(allItems);
        getItems().addAll(filtered);
    }
    /**
     * Returns a list of all formats, regardless of displaying status.
     *
     * @return a list of all formats
     */
    public List<FormatItem> getAllItems() {
        return allItems;
    }
    /**
     * Returns a list of current showing formats.
     * <p>
     * This is filtered by the format filter.
     *
     * @return a list of current showing formats
     */
    public List<FormatItem> getShowingItems() {
        return getItems();
    }
    /**
     * Returns a map containing all custom formats.
     * <p>
     * The keys are the extensions and the values are the descriptions
     *
     * @return a map of all custom formats
     */
    public Map<String, String> getCustomFormats() {
        return customFormats;
    }
    /**
     * Sets the custom formats.
     *
     * @param customFormats custom formats
     */
    public void setCustomFormats(Map<String, String> customFormats) {
        this.customFormats = customFormats;
        knownFormats.addAll(customFormats.keySet());
    }
    /**
     * Returns a set of all known formats, including custom formats.
     *
     * @return a set of all known formats, including custom formats
     */
    public Set<String> getKnownFormats() {
        return knownFormats;
    }
    /**
     * Returns a set of extensions of selected formats.
     *
     * @return a set of extensions of selected formats
     */
    public Set<String> getSelectedFormats() {
        Set<String> extensions = new HashSet<>();
        for (FormatItem formatItem : allItems) {
            if (formatItem.getCheckBox().isSelected()) extensions.add(formatItem.getExtension());
        }
        return extensions;
    }
    /**
     * This method is just used for restoring selection status of the format table.
     *
     * @param selectedFormats old selected formats
     */
    public void selectFormats(Set<String> selectedFormats) {
        for (FormatItem formatItem : allItems) {
            if (selectedFormats.contains(formatItem.getExtension())) formatItem.getCheckBox().setSelected(true);
        }
    }
}
package trashsoftware.deepSearcher2.fxml.widgets;
import javafx.beans.property.ReadOnlyIntegerProperty;
import javafx.beans.property.ReadOnlyIntegerWrapper;
import javafx.beans.value.ChangeListener;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Node;
import javafx.scene.control.ScrollPane;
import javafx.scene.layout.VBox;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
public class TextFieldList extends ScrollPane {
    private final ReadOnlyIntegerWrapper selectedIndexWrapper = new ReadOnlyIntegerWrapper(-1);
    private final List<ChangeListener<Boolean>> itemFocusListeners = new ArrayList<>();
    @FXML
    private VBox baseList;
    public TextFieldList() throws IOException {
        FXMLLoader loader = new FXMLLoader(getClass()
                .getResource("/trashsoftware/deepSearcher2/fxml/widgets/textFieldList.fxml"));
        loader.setRoot(this);
        loader.setController(this);
        loader.load();
        setFitToWidth(true);
        initializeListener();
    }
    public ObservableList<Node> getTextFields() {
        return baseList.getChildren();
    }
    public ReadOnlyIntegerProperty selectedIndexProperty() {
        return selectedIndexWrapper;
    }
    public int getSelectedIndex() {
        return selectedIndexWrapper.intValue();
    }
    private void initializeListener() {
        getTextFields().addListener((ListChangeListener<Node>) change -> {
            change.next();
            if (change.wasAdded() && change.getAddedSize() == 1) {
                final int thisIndex = change.getTo() - 1;
                Node added = getTextFields().get(thisIndex);
                ChangeListener<Boolean> focusListener = (observableValue, aBoolean, t1) -> {
                    if (t1) selectedIndexWrapper.setValue(thisIndex);
                };
                added.focusedProperty().addListener(focusListener);
                itemFocusListeners.add(thisIndex, focusListener);
            } else if (change.wasRemoved() && change.getRemovedSize() == 1) {
                final int removedIndex = change.getFrom();
                itemFocusListeners.remove(removedIndex);
                for (int i = removedIndex; i < getTextFields().size(); i++) {  // decreases the index stored in
                    // listeners of every element after the removed item
                    final int index = i;
                    Node node = getTextFields().get(index);
                    node.focusedProperty().removeListener(itemFocusListeners.get(index));
                    ChangeListener<Boolean> focusListener = (observableValue, aBoolean, t1) -> {
                        if (t1) selectedIndexWrapper.setValue(index);
                    };
                    node.focusedProperty().addListener(focusListener);
                    itemFocusListeners.set(index, focusListener);
                }
            }
        });
    }
}
package trashsoftware.deepSearcher2.guiItems;
import trashsoftware.deepSearcher2.util.Util;
import java.util.ResourceBundle;
/**
 * A class that contains a file's size and can convert size in byte to a readable form.
 * <p>
 * This class is comparable by its size.
 */
public class FileSizeItem implements Comparable<FileSizeItem> {
    private final long size;
    private final ResourceBundle bundle;
    FileSizeItem(long size, ResourceBundle bundle) {
        this.size = size;
        this.bundle = bundle;
    }
    @Override
    public String toString() {
        return Util.sizeToReadable(size, bundle.getString("bytes"));
    }
    @Override
    public int compareTo(FileSizeItem o) {
        return Long.compare(size, o.size);
    }
}
package trashsoftware.deepSearcher2.guiItems;
import trashsoftware.deepSearcher2.fxml.widgets.FormatTable;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
/**
 * A categorical item of the filter combobox.
 */
public class FormatFilterItem {
    private final FormatTable parent;
    private final FormatType filterType;
    private final String showing;
    public FormatFilterItem(FormatType filterType, String showing, FormatTable parent) {
        this.filterType = filterType;
        this.showing = showing;
        this.parent = parent;
    }
    public List<FormatItem> filter(List<FormatItem> allFormats) {
        List<FormatItem> result = new ArrayList<>();
        if (filterType == FormatType.ALL) {
            result.addAll(allFormats);
        } else if (filterType == FormatType.OTHERS) {
            for (FormatItem fi : allFormats) {
                if (!parent.getKnownFormats().contains(fi.getExtension())) result.add(fi);
            }
        } else if (filterType == FormatType.CUSTOMS) {
            for (FormatItem fi : allFormats) {
                if (parent.getCustomFormats().containsKey(fi.getExtension())) result.add(fi);
            }
        } else {
            Set<String> fmts = FormatTable.FMT_MAP.get(filterType);
            for (FormatItem fi : allFormats) {
                if (fmts.contains(fi.getExtension())) result.add(fi);
            }
        }
        return result;
    }
    @Override
    public String toString() {
        return showing;
    }
}
package trashsoftware.deepSearcher2.guiItems;
import javafx.fxml.FXML;
import javafx.scene.control.CheckBox;
public class FormatItem implements Comparable<FormatItem> {
    private final String extension;
    private final String description;
    private final CheckBox checkBox = new CheckBox();
    /**
     * Constructor.
     *
     * @param extension   the file extension without dot
     * @param description the description of this format
     */
    public FormatItem(String extension, String description) {
        this.extension = extension;
        this.description = description;
    }
    @FXML
    public String getDescription() {
        return description;
    }
    @FXML
    public String getDottedExtension() {
        return "." + extension;
    }
    @FXML
    public CheckBox getCheckBox() {
        return checkBox;
    }
    public String getExtension() {
        return extension;
    }
    @Override
    public int compareTo(FormatItem o) {
        return extension.compareTo(o.extension);
    }
    @Override
    public String toString() {
        return "FormatItem{" + extension + ", " + description + '}';
    }
}
package trashsoftware.deepSearcher2.guiItems;
public enum FormatType {
    ALL,
    TEXT,
    CODES,
    MS_OFFICE,
    DOCUMENTS,
    OTHERS,
    CUSTOMS
}
package trashsoftware.deepSearcher2.guiItems;
import javafx.fxml.FXML;
import trashsoftware.deepSearcher2.fxml.Client;
import trashsoftware.deepSearcher2.searcher.PrefSet;
import java.io.File;
import java.text.DateFormat;
import java.util.Date;
import java.util.stream.Collectors;
public class HistoryItem {
    private final static DateFormat SHOWN_TIME_FORMAT = DateFormat.getDateTimeInstance(
            DateFormat.SHORT,
            DateFormat.SHORT,
            Client.getBundle().getLocale());
    private final PrefSet prefSet;
    private final Date date;
    public HistoryItem(PrefSet prefSet, Date date) {
        this.prefSet = prefSet;
        this.date = date;
    }
    private static String mergeString(Iterable<String> iterable, String connector) {
        StringBuilder builder = new StringBuilder();
        for (String p : iterable) {
            builder.append(p).append(connector);
        }
        builder.setLength(builder.length() - connector.length());
        return builder.toString();
    }
    @FXML
    public String getPattern() {
        return mergeString(prefSet.getTargets(), ",");
    }
    @FXML
    public String getDirSearched() {
        return mergeString(prefSet.getSearchDirs().stream()
                .map(File::getAbsolutePath)
                .collect(Collectors.toList()), ",");
    }
    @FXML
    public String getDateTime() {
        return SHOWN_TIME_FORMAT.format(date);
    }
    public String getPatternLines() {
        return mergeString(prefSet.getTargets(), "\n");
    }
    public String getDirSearchedLines() {
        return mergeString(prefSet.getSearchDirs().stream()
                .map(File::getAbsolutePath)
                .collect(Collectors.toList()), "\n");
    }
}
package trashsoftware.deepSearcher2.guiItems;
import javafx.fxml.FXML;
import trashsoftware.deepSearcher2.searcher.ContentResult;
import trashsoftware.deepSearcher2.util.Util;
import java.io.File;
import java.util.Map;
import java.util.ResourceBundle;
public class ResultItem {
    private final File file;
    private final FileSizeItem fileSizeItem;
    private final boolean[] matchModes;
    private final ResourceBundle bundle;
    private final ResourceBundle fileTypeBundle;
    private final Map<String, String> customFormats;
    private ContentResult contentRes;
    private ResultItem(File file,
                       boolean matchName,
                       boolean matchContent,
                       ResourceBundle bundle,
                       ResourceBundle fileTypeBundle,
                       ContentResult contentRes,
                       Map<String, String> customFormats) {
        this.file = file;
        this.matchModes = new boolean[]{matchName, matchContent};
        this.bundle = bundle;
        this.fileTypeBundle = fileTypeBundle;
        this.fileSizeItem = file.isDirectory() ? null : new FileSizeItem(file.length(), bundle);
        this.contentRes = contentRes;
        this.customFormats = customFormats;
    }
    public static ResultItem createNameMatch(File file,
                                             ResourceBundle bundle,
                                             ResourceBundle fileTypeBundle,
                                             Map<String, String> customFormats) {
        return new ResultItem(
                file, true, false, bundle, fileTypeBundle, null, customFormats);
    }
    public static ResultItem createContentMatch(File file,
                                                ResourceBundle bundle,
                                                ResourceBundle fileTypeBundle,
                                                ContentResult contentRes,
                                                Map<String, String> customFormats) {
        return new ResultItem(
                file, false, true, bundle, fileTypeBundle, contentRes, customFormats);
    }
    public void setContentRes(ContentResult contentRes) {
        this.contentRes = contentRes;
        this.matchModes[1] = true;
    }
    @FXML
    public String getName() {
        return file.getAbsolutePath();
    }
    @FXML
    public String getMode() {
        if (matchModes[0]) {
            if (matchModes[1]) {
                return bundle.getString("matchedName") + ", " + bundle.getString("matchedContent");
            } else {
                return bundle.getString("matchedName");
            }
        } else if (matchModes[1]) {
            return bundle.getString("matchedContent");
        } else {
            throw new RuntimeException("Result that does not match any could not be here, must be a bug");
        }
    }
    @FXML
    public FileSizeItem getSize() {
        return fileSizeItem;  // nullable
    }
    @FXML
    public String getType() {
        if (file.isDirectory()) return bundle.getString("folder");
        String name = file.getName();
        String ext = Util.getFileExtension(name);
        if (ext.equals("")) return bundle.getString("file");
        else if (fileTypeBundle.containsKey(ext)) return fileTypeBundle.getString(ext);
        else if (customFormats.containsKey(ext)) return customFormats.get(ext);
        else return ext.toUpperCase() + " " + bundle.getString("file");
    }
    public File getFile() {
        return file;
    }
    public String showInfo() {
        if (contentRes != null) {
            return contentRes.getAsString(bundle);
        } else {
            return null;
        }
    }
}
package trashsoftware.deepSearcher2.guiItems;
import trashsoftware.deepSearcher2.fxml.settingsPages.Page;
public class SettingsItem {
    private final String name;
    private final Page page;
    public SettingsItem(String name, Page page) {
        this.name = name;
        this.page = page;
    }
    public Page getPage() {
        return page;
    }
    @Override
    public String toString() {
        return name;
    }
}
package trashsoftware.deepSearcher2.searcher;
import trashsoftware.deepSearcher2.fxml.Client;
import trashsoftware.deepSearcher2.searcher.matchers.StringMatcher;
import trashsoftware.deepSearcher2.searcher.matchers.regexMatchers.NativeRegexMatcher;
import trashsoftware.deepSearcher2.searcher.matchers.regularMatchers.KMPMatcher;
import trashsoftware.deepSearcher2.searcher.matchers.regularMatchers.NaiveMatcher;
import trashsoftware.deepSearcher2.searcher.matchers.regularMatchers.NativeMatcher;
import trashsoftware.deepSearcher2.searcher.matchers.regularMatchers.SundayMatcher;
import trashsoftware.deepSearcher2.searcher.matchers.wordMatchers.HashedWordMatcher;
import trashsoftware.deepSearcher2.searcher.matchers.wordMatchers.NaiveWordMatcher;
/**
 * An interface of enums that represents a matching algorithm.
 */
public interface Algorithm {
    /**
     * Returns the string matcher class corresponding to this algorithm.
     *
     * @return the string matcher class corresponding to this algorithm
     */
    Class<? extends StringMatcher> getMatcherClass();
    /**
     * Algorithms for regular searching.
     */
    enum Regular implements Algorithm {
        AUTO("algAuto", null),
        NATIVE("algNative", NativeMatcher.class),
        NAIVE("algNaive", NaiveMatcher.class),
        KMP("algKmp", KMPMatcher.class),
        SUNDAY("algSunday", SundayMatcher.class);
        private final Class<? extends StringMatcher> matcherClass;
        private final String showKey;
        Regular(String showKey, Class<? extends StringMatcher> matcherClass) {
            this.showKey = showKey;
            this.matcherClass = matcherClass;
        }
        @Override
        public Class<? extends StringMatcher> getMatcherClass() {
            return matcherClass;
        }
        @Override
        public String toString() {
            return Client.getBundle().getString(showKey);
        }
    }
    /**
     * Algorithms for full word searching.
     */
    enum Word implements Algorithm {
        NAIVE("algNaive", NaiveWordMatcher.class),
        HASH("algHash", HashedWordMatcher.class);
        private final Class<? extends StringMatcher> matcherClass;
        private final String showKey;
        Word(String showKey, Class<? extends StringMatcher> matcherClass) {
            this.showKey = showKey;
            this.matcherClass = matcherClass;
        }
        @Override
        public Class<? extends StringMatcher> getMatcherClass() {
            return matcherClass;
        }
        @Override
        public String toString() {
            return Client.getBundle().getString(showKey);
        }
    }
    /**
     * Algorithms for regular expression matching.
     */
    enum Regex implements Algorithm {
        NATIVE("algNative", NativeRegexMatcher.class);
        private final Class<? extends StringMatcher> matcherClass;
        private final String showKey;
        Regex(String showKey, Class<? extends StringMatcher> matcherClass) {
            this.showKey = showKey;
            this.matcherClass = matcherClass;
        }
        @Override
        public Class<? extends StringMatcher> getMatcherClass() {
            return matcherClass;
        }
        @Override
        public String toString() {
            return Client.getBundle().getString(showKey);
        }
    }
}
package trashsoftware.deepSearcher2.searcher;
import java.util.List;
import java.util.ResourceBundle;
/**
 * A result of file content search.
 * <p>
 * This may include some keys, for example, pages, lines.
 * Note that all indexes are counted from 1.
 */
public class ContentResult {
    private Category key1;  // null if not specified
    private Category key2;  // null if not specified
    private List<Integer> values1;
    private List<Integer> values2;
    private List<StringValue> strValues;
    public ContentResult() {
    }
    public ContentResult(Category key1, List<Integer> values1) {
        this.key1 = key1;
        this.values1 = values1;
    }
    public ContentResult(Category key1, List<Integer> values1, Category key2, List<Integer> values2) {
        this.key1 = key1;
        this.values1 = values1;
        this.key2 = key2;
        this.values2 = values2;
    }
    public ContentResult(Category key1, List<Integer> values1, Category key2, List<Integer> values2,
                         List<StringValue> strValues) {
        this.key1 = key1;
        this.values1 = values1;
        this.key2 = key2;
        this.values2 = values2;
        this.strValues = strValues;
    }
    private static String getFmtStringByKey(ICategory key, ResourceBundle bundle) {
        return key.display(bundle);
    }
    public Category getKey1() {
        return key1;
    }
    public Category getKey2() {
        return key2;
    }
    public List<Integer> getValues1() {
        return values1;
    }
    public List<Integer> getValues2() {
        return values2;
    }
    /**
     * Returns the showing string of this content result, including all specified keys, e.g. pages, lines.
     * <p>
     * If no keys are specified, returns {@code null}
     *
     * @param bundle the language bundle
     * @return the showing content result
     */
    public String getAsString(ResourceBundle bundle) {
        StringBuilder builder = new StringBuilder();
        if (key1 != null) {
            List<Integer> v1 = getValues1();
            String fmt1 = getFmtStringByKey(getKey1(), bundle);
            if (key2 != null) {
                List<Integer> v2 = getValues2();
                if (v1.size() != v2.size()) throw new RuntimeException("Unexpected unequal size.");
                String fmt2 = getFmtStringByKey(getKey2(), bundle);
                if (strValues != null) {
                    if (v1.size() != strValues.size()) throw new RuntimeException("Unexpected unequal size.");
                    for (int i = 0; i < v1.size(); i++) {
                        builder.append(String.format(fmt1, v1.get(i)))
                                .append(", ")
                                .append(String.format(fmt2, v2.get(i)))
                                .append(", ")
                                .append(strValues.get(i).getShowString(bundle))
                                .append('\n');
                    }
                } else {
                    for (int i = 0; i < v1.size(); i++) {
                        builder.append(String.format(fmt1, v1.get(i)))
                                .append(", ")
                                .append(String.format(fmt2, v2.get(i)))
                                .append('\n');
                    }
                }
            } else {
                for (Integer integer : v1) {
                    builder.append(String.format(fmt1, integer))
                            .append('\n');
                }
            }
        } else return null;  // no keys are specified
        return builder.toString();
    }
    /**
     * A enum of all secondary keys.
     * <p>
     * This is used for displaying details such as "page 2, line 15" in the result table.
     */
    public enum Category implements ICategory {
        CHAR("characterFmt"),
        LINE("lineFmt"),
        PARAGRAPH("paragraphFmt"),
        PAGE("pageFmt"),
        BLOCK("blockFmt"),
        ROW("rowFmt"),
        COLUMN("colFmt");
        private final String displayKey;
        Category(String displayKey) {
            this.displayKey = displayKey;
        }
        @Override
        public String display(ResourceBundle bundle) {
            return bundle.getString(displayKey);
        }
    }
    /**
     * A enum of all position keys.
     */
    public enum ValueCategory implements ICategory {
        TITLE("titleStr"),
        TEXT("textStr"),
        TABLE("tableStr");
        private final String displayKey;
        ValueCategory(String displayKey) {
            this.displayKey = displayKey;
        }
        @Override
        public String display(ResourceBundle bundle) {
            return bundle.getString(displayKey);
        }
    }
    /**
     * An interface of two types of categories.
     */
    private interface ICategory {
        String display(ResourceBundle resourceBundle);
    }
    public static class StringValue {
        private final ValueCategory category;
        private final String realStringValue;
        public StringValue(ValueCategory category) {
            this.category = category;
            this.realStringValue = null;
        }
        public StringValue(String realStringValue) {
            this.category = null;
            this.realStringValue = realStringValue;
        }
        private String getShowString(ResourceBundle bundle) {
            if (category != null) {
                return getFmtStringByKey(category, bundle);
            } else {
                return realStringValue;
            }
        }
    }
}
package trashsoftware.deepSearcher2.searcher;
import trashsoftware.deepSearcher2.searcher.matchers.MatcherFactory;
import trashsoftware.deepSearcher2.searcher.matchers.StringMatcher;
import java.io.File;
import java.util.List;
/**
 * The abstract class for searcher that searches the content of a specific file format.
 */
public abstract class ContentSearcher {
    protected File file;
    protected MatcherFactory matcherFactory;
    protected boolean caseSensitive;
    /**
     * Constructor.
     *
     * @param file           the file to be searched
     * @param matcherFactory matcher factory which produces a string searcher according to algorithm and match mode
     * @param caseSensitive  is case sensitive
     */
    public ContentSearcher(File file, MatcherFactory matcherFactory, boolean caseSensitive) {
        this.file = file;
        this.matcherFactory = matcherFactory;
        this.caseSensitive = caseSensitive;
    }
    /**
     * @param targets patterns to be searched
     * @return search result if all targets are found in this file, otherwise return {@code null}.
     */
    public abstract ContentResult searchAll(List<String> targets);
    /**
     * @param targets patterns to be searched
     * @return search result if at least one target is found in this file, otherwise return {@code null}.
     */
    public abstract ContentResult searchAny(List<String> targets);
    /**
     * @return the concatenated file content, or {@code null} if the file is not readable
     */
    protected abstract String readWholeFile();
    /**
     * Search all, reads the whole file as a string.
     *
     * @param targets patterns to be searched
     * @return the content result with no keys
     */
    public ContentResult searchAllWhole(List<String> targets) {
        String content = readWholeFile();
        if (content == null) return null;
        if (!caseSensitive) content = content.toLowerCase();
        StringMatcher matcher = matcherFactory.createMatcher(content);
        for (String tar : targets) {
            if (matcher.search(tar) == -1) return null;
        }
        return new ContentResult();
    }
    /**
     * Search any, reads the whole file as a string.
     *
     * @param targets patterns to be searched
     * @return the content result with no keys
     */
    public ContentResult searchAnyWhole(List<String> targets) {
        String content = readWholeFile();
        if (content == null) return null;
        if (!caseSensitive) content = content.toLowerCase();
        StringMatcher matcher = matcherFactory.createMatcher(content);
        for (String tar : targets) {
            if (matcher.search(tar) >= 0) return new ContentResult();
        }
        return null;
    }
}
package trashsoftware.deepSearcher2.searcher.contentSearchers;
import org.apache.poi.hwpf.extractor.WordExtractor;
import trashsoftware.deepSearcher2.searcher.ContentResult;
import trashsoftware.deepSearcher2.searcher.matchers.MatcherFactory;
import java.io.File;
import java.io.FileInputStream;
import java.util.List;
public class DocSearcher extends TwoKeysSearcher {
    public DocSearcher(File file, MatcherFactory matcherFactory, boolean caseSensitive) {
        super(file, matcherFactory, caseSensitive, ContentResult.Category.PARAGRAPH, ContentResult.Category.CHAR);
    }
    @Override
    protected void searchFile(List<String> targets) {
        try (WordExtractor we = new WordExtractor(new FileInputStream(file))) {
            String[] paragraphs = we.getParagraphText();
            for (int i = 0; i < paragraphs.length; i++) {
                String paragraph = paragraphs[i];
                searchInString(paragraph, targets, i);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    @Override
    protected String readWholeFile() {
        try (WordExtractor we = new WordExtractor(new FileInputStream(file))) {
            return we.getTextFromPieces();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}
package trashsoftware.deepSearcher2.searcher.contentSearchers;
import org.apache.poi.hwpf.extractor.WordExtractor;
import org.apache.poi.xwpf.usermodel.XWPFDocument;
import org.apache.poi.xwpf.usermodel.XWPFParagraph;
import trashsoftware.deepSearcher2.searcher.ContentResult;
import trashsoftware.deepSearcher2.searcher.matchers.MatcherFactory;
import java.io.File;
import java.io.FileInputStream;
import java.util.List;
public class DocxSearcher extends TwoKeysSearcher {
    public DocxSearcher(File file, MatcherFactory matcherFactory, boolean caseSensitive) {
        super(file, matcherFactory, caseSensitive, ContentResult.Category.PARAGRAPH, ContentResult.Category.CHAR);
    }
    @Override
    protected void searchFile(List<String> targets) {
        try (XWPFDocument docx = new XWPFDocument(new FileInputStream(file))) {
            List<XWPFParagraph> paragraphs = docx.getParagraphs();
            for (int i = 0; i < paragraphs.size(); i++) {
                String par = paragraphs.get(i).getText();
                searchInString(par, targets, i);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    @Override
    protected String readWholeFile() {
        try (XWPFDocument docx = new XWPFDocument(new FileInputStream(file))) {
            StringBuilder builder = new StringBuilder();
            List<XWPFParagraph> paragraphs = docx.getParagraphs();
            for (XWPFParagraph paragraph : paragraphs) {
                String par = paragraph.getText();
                builder.append(par).append('\n');
            }
            return builder.toString();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}
package trashsoftware.deepSearcher2.searcher.contentSearchers;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import trashsoftware.deepSearcher2.searcher.ContentResult;
import trashsoftware.deepSearcher2.searcher.matchers.MatcherFactory;
import java.io.File;
import java.util.List;
/**
 * Content searcher for Microsoft Excel formats.
 * <p>
 * This class is overridden by two subclasses which search .xls and .xlsx
 */
abstract class ExcelSearcher extends TwoIntOneStrSearcher {
    public ExcelSearcher(File file, MatcherFactory matcherFactory, boolean caseSensitive) {
        super(
                file,
                matcherFactory,
                caseSensitive,
                ContentResult.Category.ROW,
                ContentResult.Category.COLUMN);
    }
    void searchOneSheet(Sheet sheet, List<String> targets) {
        int lastRowNum = sheet.getLastRowNum();
        for (int r = sheet.getFirstRowNum(); r <= lastRowNum; r++) {
            Row row = sheet.getRow(r);
            int lastCellNum = row.getLastCellNum();
            for (int c = row.getFirstCellNum(); c < lastCellNum; c++) {
                Cell cell = row.getCell(c);
                if (cell != null) {
                    searchInStringFixedV2(
                            cell.toString(),
                            targets,
                            r + 1,
                            c + 1,
                            sheet.getSheetName());
                }
            }
        }
    }
    String sheetToString(Sheet sheet) {
        StringBuilder builder = new StringBuilder().append(sheet.getSheetName()).append('\n');
        int lastRowNum = sheet.getLastRowNum();
        for (int r = sheet.getFirstRowNum(); r <= lastRowNum; r++) {
            Row row = sheet.getRow(r);
            int lastCellNum = row.getLastCellNum();
            for (int c = row.getFirstCellNum(); c < lastCellNum; c++) {
                Cell cell = row.getCell(c);
                builder.append(cell.toString()).append(',');
            }
            builder.append('\n');
        }
        return builder.toString();
    }
}
package trashsoftware.deepSearcher2.searcher.contentSearchers;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.text.PDFTextStripper;
import trashsoftware.deepSearcher2.searcher.ContentResult;
import trashsoftware.deepSearcher2.searcher.matchers.MatcherFactory;
import java.io.File;
import java.util.List;
/**
 * Content searcher of PDF documents.
 */
public class PdfSearcher extends TwoKeysSearcher {
    public PdfSearcher(File file, MatcherFactory matcherFactory, boolean caseSensitive) {
        super(file, matcherFactory, caseSensitive, ContentResult.Category.PAGE, ContentResult.Category.CHAR);
    }
    @Override
    protected void searchFile(List<String> targets) {
        try (PDDocument document = PDDocument.load(file)) {
            if (!document.isEncrypted()) {
                PDFTextStripper stripper = new PDFTextStripper();
                int endPage = document.getNumberOfPages();
                for (int i = 1; i <= endPage; i++) {
                    stripper.setStartPage(i);
                    stripper.setEndPage(i + 1);
                    String page = stripper.getText(document);
                    searchInString(page, targets, i);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    @Override
    protected String readWholeFile() {
        try (PDDocument document = PDDocument.load(file)) {
            if (!document.isEncrypted()) {
                PDFTextStripper stripper = new PDFTextStripper();
                int endPage = document.getNumberOfPages();
                stripper.setStartPage(1);
                stripper.setEndPage(endPage);
                return stripper.getText(document);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}
package trashsoftware.deepSearcher2.searcher.contentSearchers;
import trashsoftware.deepSearcher2.searcher.ContentResult;
import trashsoftware.deepSearcher2.searcher.matchers.MatcherFactory;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.List;
/**
 * Searcher for any plain text format.
 */
public class PlainTextSearcher extends TwoKeysSearcher {
    public PlainTextSearcher(File file, MatcherFactory matcherFactory, boolean caseSensitive) {
        super(file, matcherFactory, caseSensitive, ContentResult.Category.LINE, ContentResult.Category.CHAR);
    }
    @Override
    protected void searchFile(List<String> targets) {
        try (BufferedReader bufferedReader = new BufferedReader(new FileReader(file))) {
            String line;
            int lineCount = 1;
            while ((line = bufferedReader.readLine()) != null) {
                searchInString(line, targets, lineCount);
                lineCount++;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    @Override
    protected String readWholeFile() {
        try (BufferedReader bufferedReader = new BufferedReader(new FileReader(file))) {
            String lf = System.lineSeparator();
            StringBuilder builder = new StringBuilder();
            String line;
            while ((line = bufferedReader.readLine()) != null) {
                builder.append(line).append(lf);
            }
            return builder.toString();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}
package trashsoftware.deepSearcher2.searcher.contentSearchers;
import org.apache.poi.hslf.usermodel.*;
import trashsoftware.deepSearcher2.searcher.ContentResult;
import trashsoftware.deepSearcher2.searcher.matchers.MatcherFactory;
import java.io.File;
import java.io.FileInputStream;
import java.util.List;
public class PptSearcher extends TwoIntOneStrSearcher {
    public PptSearcher(File file, MatcherFactory matcherFactory, boolean caseSensitive) {
        super(file, matcherFactory, caseSensitive, ContentResult.Category.PAGE, ContentResult.Category.CHAR);
    }
    @Override
    protected void searchFile(List<String> targets) {
        try (HSLFSlideShow slideShow = new HSLFSlideShow(new FileInputStream(file))) {
            int page = 1;
            for (HSLFSlide slide : slideShow.getSlides()) {
                List<HSLFShape> shapes = slide.getShapes();
                String title = slide.getTitle();
                if (title != null) searchInString(title, targets, page, ContentResult.ValueCategory.TITLE);
                int pageTextCount = 0;
                for (int j = 0; j < shapes.size(); j++) {
                    HSLFShape shape = shapes.get(j);
                    if (shape instanceof HSLFTextShape) {  // text shape
                        String text = ((HSLFTextShape) shape).getText();
                        if (j == 0 && text.equals(title)) {
                            continue;  // first shape (title) already checked, if not null
                        }
                        searchInString(text,
                                targets, page, pageTextCount, ContentResult.ValueCategory.TEXT);
                        pageTextCount += text.length();
                    } else if (shape instanceof HSLFTable) {
                        HSLFTable table = (HSLFTable) shape;
                        for (int r = 0; r < table.getNumberOfRows(); r++) {
                            for (int c = 0; c < table.getNumberOfColumns(); c++) {
                                HSLFTableCell cell = table.getCell(r, c);
                                if (cell != null) {
                                    searchInString(cell.getText(), targets, page, ContentResult.ValueCategory.TABLE);
                                }
                            }
                        }
                    }
                }
                page++;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    @Override
    protected String readWholeFile() {
        try (HSLFSlideShow slideShow = new HSLFSlideShow(new FileInputStream(file))) {
            StringBuilder builder = new StringBuilder();
            for (HSLFSlide slide : slideShow.getSlides()) {
                List<HSLFShape> shapes = slide.getShapes();
                String title = slide.getTitle();
                if (title != null) builder.append(title).append('\n');
                for (int j = 0; j < shapes.size(); j++) {
                    HSLFShape shape = shapes.get(j);
                    if (shape instanceof HSLFTextShape) {  // text shape
                        String text = ((HSLFTextShape) shape).getText();
                        if (j == 0 && text.equals(title)) {
                            continue;  // first shape (title) already checked, if not null
                        }
                        builder.append(text).append('\n');
                    } else if (shape instanceof HSLFTable) {
                        HSLFTable table = (HSLFTable) shape;
                        for (int r = 0; r < table.getNumberOfRows(); r++) {
                            for (int c = 0; c < table.getNumberOfColumns(); c++) {
                                HSLFTableCell cell = table.getCell(r, c);
                                if (cell != null) builder.append(cell.getText()).append('\n');
                            }
                        }
                    }
                }
                builder.append('\f');
            }
            return builder.toString();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}
package trashsoftware.deepSearcher2.searcher.contentSearchers;
import org.apache.poi.xslf.usermodel.*;
import trashsoftware.deepSearcher2.searcher.ContentResult;
import trashsoftware.deepSearcher2.searcher.matchers.MatcherFactory;
import java.io.File;
import java.io.FileInputStream;
import java.util.List;
public class PptxSearcher extends TwoIntOneStrSearcher {
    public PptxSearcher(File file, MatcherFactory matcherFactory, boolean caseSensitive) {
        super(file, matcherFactory, caseSensitive, ContentResult.Category.PAGE, ContentResult.Category.CHAR);
    }
    @Override
    protected void searchFile(List<String> targets) {
        try (XMLSlideShow slideShow = new XMLSlideShow(new FileInputStream(file))) {
            int page = 1;
            for (XSLFSlide slide : slideShow.getSlides()) {
                List<XSLFShape> shapes = slide.getShapes();
                String title = slide.getTitle();
                if (title != null) searchInString(title, targets, page, ContentResult.ValueCategory.TITLE);
                int pageTextCount = 0;
                for (int j = 0; j < shapes.size(); j++) {
                    XSLFShape shape = shapes.get(j);
                    if (shape instanceof XSLFTextShape) {  // text shape
                        String text = ((XSLFTextShape) shape).getText();
                        if (j == 0 && text.equals(title)) {
                            continue;  // first shape (title) already checked, if not null
                        }
                        searchInString(text,
                                targets, page, pageTextCount, ContentResult.ValueCategory.TEXT);
                        pageTextCount += text.length();
                    } else if (shape instanceof XSLFTable) {
                        XSLFTable table = (XSLFTable) shape;
                        for (int r = 0; r < table.getNumberOfRows(); r++) {
                            for (int c = 0; c < table.getNumberOfColumns(); c++) {
                                XSLFTableCell cell = table.getCell(r, c);
                                if (cell != null) {
                                    searchInString(cell.getText(), targets, page, ContentResult.ValueCategory.TABLE);
                                }
                            }
                        }
                    }
                }
                page++;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    @Override
    protected String readWholeFile() {
        try (XMLSlideShow slideShow = new XMLSlideShow(new FileInputStream(file))) {
            StringBuilder builder = new StringBuilder();
            for (XSLFSlide slide : slideShow.getSlides()) {
                List<XSLFShape> shapes = slide.getShapes();
                String title = slide.getTitle();
                if (title != null) builder.append(title).append('\n');
                for (int j = 0; j < shapes.size(); j++) {
                    XSLFShape shape = shapes.get(j);
                    if (shape instanceof XSLFTextShape) {  // text shape
                        String text = ((XSLFTextShape) shape).getText();
                        if (j == 0 && text.equals(title)) {
                            continue;  // first shape (title) already checked, if not null
                        }
                        builder.append(text).append('\n');
                    } else if (shape instanceof XSLFTable) {
                        XSLFTable table = (XSLFTable) shape;
                        for (int r = 0; r < table.getNumberOfRows(); r++) {
                            for (int c = 0; c < table.getNumberOfColumns(); c++) {
                                XSLFTableCell cell = table.getCell(r, c);
                                if (cell != null) builder.append(cell.getText()).append('\n');
                            }
                        }
                    }
                }
                builder.append('\f');
            }
            return builder.toString();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}
package trashsoftware.deepSearcher2.searcher.contentSearchers;
import trashsoftware.deepSearcher2.searcher.ContentResult;
import trashsoftware.deepSearcher2.searcher.ContentSearcher;
import trashsoftware.deepSearcher2.searcher.matchers.MatcherFactory;
import trashsoftware.deepSearcher2.searcher.matchers.StringMatcher;
import java.io.File;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
/**
 * Searchers that have two int keys and one string key as sub-keys.
 * <p>
 * For example, "page", "line" as two int keys, "in shape" as string key.
 */
public abstract class TwoIntOneStrSearcher extends ContentSearcher {
    private final ContentResult.Category key1;
    private final ContentResult.Category key2;
    private final Set<String> foundTargets = new HashSet<>();
    private final List<Integer> found1s = new ArrayList<>();
    private final List<Integer> found2s = new ArrayList<>();
    private final List<ContentResult.StringValue> strValues = new ArrayList<>();
    public TwoIntOneStrSearcher(File file,
                                MatcherFactory matcherFactory,
                                boolean caseSensitive,
                                ContentResult.Category key1,
                                ContentResult.Category key2) {
        super(file, matcherFactory, caseSensitive);
        this.key1 = key1;
        this.key2 = key2;
    }
    @Override
    public ContentResult searchAll(List<String> targets) {
        foundTargets.clear();
        found1s.clear();
        found2s.clear();
        strValues.clear();
        searchFile(targets);
        if (foundTargets.size() == targets.size()) {  // all matched
            return new ContentResult(key1, found1s,
                    key2, found2s, strValues);
        }
        return null;
    }
    @Override
    public ContentResult searchAny(List<String> targets) {
        foundTargets.clear();
        found1s.clear();
        found2s.clear();
        strValues.clear();
        searchFile(targets);
        if (foundTargets.size() > 0) {  // at least one matched
            return new ContentResult(key1, found1s,
                    key2, found2s, strValues);
        }
        return null;
    }
    protected void searchInString(String string,
                                  List<String> targets,
                                  int value1,
                                  ContentResult.ValueCategory strCategory) {
        searchInString(string, targets, value1, 0, strCategory);
    }
    protected void searchInString(String string,
                                  List<String> targets,
                                  int value1,
                                  int value2Base,
                                  ContentResult.ValueCategory strCategory) {
        if (!caseSensitive) string = string.toLowerCase();
        StringMatcher matcher = matcherFactory.createMatcher(string);
        for (String tar : targets) {
            int pos = matcher.search(tar);
            if (pos >= 0) {
                foundTargets.add(tar);
                found1s.add(value1);
                found2s.add(pos + value2Base + 1);  // add one because index 0 means first (1st) element
                strValues.add(new ContentResult.StringValue(strCategory));
            }
        }
    }
    protected void searchInStringFixedV2(String string, List<String> targets, int value1, int value2,
                                         String strValue) {
        if (!caseSensitive) string = string.toLowerCase();
        StringMatcher matcher = matcherFactory.createMatcher(string);
        for (String tar : targets) {
            int pos = matcher.search(tar);
            if (pos >= 0) {
                foundTargets.add(tar);
                found1s.add(value1);
                found2s.add(value2);
                strValues.add(new ContentResult.StringValue(strValue));
            }
        }
    }
    protected abstract void searchFile(List<String> targets);
}
package trashsoftware.deepSearcher2.searcher.contentSearchers;
import trashsoftware.deepSearcher2.searcher.ContentResult;
import trashsoftware.deepSearcher2.searcher.ContentSearcher;
import trashsoftware.deepSearcher2.searcher.matchers.MatcherFactory;
import trashsoftware.deepSearcher2.searcher.matchers.StringMatcher;
import java.io.File;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
/**
 * Searchers that have two ints as sub-keys.
 * <p>
 * For example, "page" and "line" are two int keys.
 */
public abstract class TwoKeysSearcher extends ContentSearcher {
    private final ContentResult.Category key1;
    private final ContentResult.Category key2;
    private final Set<String> foundTargets = new HashSet<>();
    private final List<Integer> found1s = new ArrayList<>();
    private final List<Integer> found2s = new ArrayList<>();
    public TwoKeysSearcher(File file,
                           MatcherFactory matcherFactory,
                           boolean caseSensitive,
                           ContentResult.Category key1,
                           ContentResult.Category key2) {
        super(file, matcherFactory, caseSensitive);
        this.key1 = key1;
        this.key2 = key2;
    }
    @Override
    public ContentResult searchAll(List<String> targets) {
        foundTargets.clear();
        found1s.clear();
        found2s.clear();
        searchFile(targets);
        if (foundTargets.size() == targets.size()) {  // all matched
            return new ContentResult(key1, found1s,
                    key2, found2s);
        }
        return null;
    }
    @Override
    public ContentResult searchAny(List<String> targets) {
        foundTargets.clear();
        found1s.clear();
        found2s.clear();
        searchFile(targets);
        if (foundTargets.size() > 0) {  // at least one matched
            return new ContentResult(key1, found1s,
                    key2, found2s);
        }
        return null;
    }
    protected void searchInString(String string, List<String> targets, int value1) {
        if (!caseSensitive) string = string.toLowerCase();
        StringMatcher matcher = matcherFactory.createMatcher(string);
        for (String tar : targets) {
            int pos = matcher.search(tar);
            if (pos >= 0) {
                foundTargets.add(tar);
                found1s.add(value1);
                found2s.add(pos + 1);
            }
        }
    }
    protected void searchInString(String string, List<String> targets, int value1, int value2) {
        if (!caseSensitive) string = string.toLowerCase();
        StringMatcher matcher = matcherFactory.createMatcher(string);
        for (String tar : targets) {
            int pos = matcher.search(tar);
            if (pos >= 0) {
                foundTargets.add(tar);
                found1s.add(value1);
                found2s.add(value2);
            }
        }
    }
    protected abstract void searchFile(List<String> targets);
}
package trashsoftware.deepSearcher2.searcher.contentSearchers;
import org.apache.poi.hssf.usermodel.HSSFSheet;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import trashsoftware.deepSearcher2.searcher.matchers.MatcherFactory;
import java.io.File;
import java.io.FileInputStream;
import java.util.List;
public class XlsSearcher extends ExcelSearcher {
    public XlsSearcher(File file, MatcherFactory matcherFactory, boolean caseSensitive) {
        super(file, matcherFactory, caseSensitive);
    }
    @Override
    protected void searchFile(List<String> targets) {
        try (HSSFWorkbook workbook = new HSSFWorkbook(new FileInputStream(file))) {
            for (int i = 0; i < workbook.getNumberOfSheets(); i++) {
                HSSFSheet sheet = workbook.getSheetAt(i);
                searchOneSheet(sheet, targets);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    @Override
    protected String readWholeFile() {
        try (HSSFWorkbook workbook = new HSSFWorkbook(new FileInputStream(file))) {
            StringBuilder builder = new StringBuilder();
            for (int i = 0; i < workbook.getNumberOfSheets(); i++) {
                HSSFSheet sheet = workbook.getSheetAt(i);
                builder.append(sheetToString(sheet)).append("\f");
            }
            return builder.toString();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}
package trashsoftware.deepSearcher2.searcher.contentSearchers;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import trashsoftware.deepSearcher2.searcher.matchers.MatcherFactory;
import java.io.File;
import java.io.FileInputStream;
import java.util.List;
public class XlsxSearcher extends ExcelSearcher {
    public XlsxSearcher(File file, MatcherFactory matcherFactory, boolean caseSensitive) {
        super(file, matcherFactory, caseSensitive);
    }
    @Override
    protected void searchFile(List<String> targets) {
        try (XSSFWorkbook workbook = new XSSFWorkbook(new FileInputStream(file))) {
            for (int i = 0; i < workbook.getNumberOfSheets(); i++) {
                XSSFSheet sheet = workbook.getSheetAt(i);
                searchOneSheet(sheet, targets);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    @Override
    protected String readWholeFile() {
        try (XSSFWorkbook workbook = new XSSFWorkbook(new FileInputStream(file))) {
            StringBuilder builder = new StringBuilder();
            for (int i = 0; i < workbook.getNumberOfSheets(); i++) {
                XSSFSheet sheet = workbook.getSheetAt(i);
                builder.append(sheetToString(sheet)).append("\f");
            }
            return builder.toString();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}
package trashsoftware.deepSearcher2.searcher;
public class InvalidClassException extends RuntimeException {
    public InvalidClassException(String msg, Throwable cause) {
        super(msg, cause);
    }
}
package trashsoftware.deepSearcher2.searcher.matchers;
import trashsoftware.deepSearcher2.searcher.matchers.regularMatchers.NativeMatcher;
import trashsoftware.deepSearcher2.searcher.matchers.regularMatchers.SundayMatcher;
/**
 * A matcher factory that produces a best algorithms for the given text.
 */
public class AutoRegularMatcherFactory extends MatcherFactory {
    /**
     * If the given string has length exceeds {@code THRESHOLD}, use a high-level matcher.
     * Otherwise use the native matcher.
     */
    public static final int THRESHOLD = 1000;
    public StringMatcher createMatcher(String string) {
        if (string.length() > THRESHOLD) {
            return new SundayMatcher(string);
        } else {
            return new NativeMatcher(string);
        }
    }
}
package trashsoftware.deepSearcher2.searcher.matchers;
import trashsoftware.deepSearcher2.searcher.InvalidClassException;
import java.lang.reflect.InvocationTargetException;
/**
 * A matcher factory that uses a fixed algorithm to search.
 */
public class FixedMatcherFactory extends MatcherFactory {
    private final Class<? extends StringMatcher> matcherClass;
    public FixedMatcherFactory(Class<? extends StringMatcher> matcherClass) {
        this.matcherClass = matcherClass;
    }
    public StringMatcher createMatcher(String string) {
        try {
            return matcherClass.getDeclaredConstructor(String.class).newInstance(string);
        } catch (InvocationTargetException
                | NoSuchMethodException
                | InstantiationException
                | IllegalAccessException e) {
            throw new InvalidClassException("Unexpected matcher. ", e);
        }
    }
}
package trashsoftware.deepSearcher2.searcher.matchers;
import trashsoftware.deepSearcher2.searcher.Algorithm;
import trashsoftware.deepSearcher2.searcher.PrefSet;
public abstract class MatcherFactory {
    /**
     * Creates a matcher factory according to a pref set.
     *
     * @param prefSet the pref set
     * @return the new factory
     */
    public static MatcherFactory createFactoryByPrefSet(PrefSet prefSet) {
        Algorithm alg;
        if (prefSet.getMatchMode() == MatchMode.NORMAL) {
            alg = prefSet.getMatchingAlgorithm();
            if (alg == Algorithm.Regular.AUTO) return new AutoRegularMatcherFactory();
        } else if (prefSet.getMatchMode() == MatchMode.WORD) {
            alg = prefSet.getWordMatchingAlgorithm();
        } else if (prefSet.getMatchMode() == MatchMode.REGEX) {
            alg = prefSet.getRegexAlgorithm();
        } else {
            throw new RuntimeException("Invalid match mode");
        }
        return new FixedMatcherFactory(alg.getMatcherClass());
    }
    /**
     * Creates a real matcher.
     *
     * @param string the string to be searched
     * @return the matcher
     */
    public abstract StringMatcher createMatcher(String string);
}
package trashsoftware.deepSearcher2.searcher.matchers;
public enum MatchMode {
    NORMAL,
    WORD,
    REGEX
}
package trashsoftware.deepSearcher2.searcher.matchers.regexMatchers;
import trashsoftware.deepSearcher2.searcher.matchers.StringMatcher;
public class NativeRegexMatcher extends StringMatcher {
    public NativeRegexMatcher(String string) {
        super(string);
    }
    @Override
    public int search(String target) {
        return string.matches(target) ? 1 : -1;
    }
//    public static void main(String[] args) {
//        System.out.println("a1234.txt".matches("[a-zA-Z][0-9]*.[a-z]"));
//        System.out.println("a1234.txt".matches("[a-zA-Z][0-9]*\\.[a-z]*"));
//    }
}
package trashsoftware.deepSearcher2.searcher.matchers.regularMatchers;
import trashsoftware.deepSearcher2.searcher.matchers.StringMatcher;
public class BoyerMooreMatcher extends StringMatcher {
    public BoyerMooreMatcher(String string) {
        super(string);
    }
    @Override
    public int search(String pattern) {
        return -1;
    }
}
package trashsoftware.deepSearcher2.searcher.matchers.regularMatchers;
import trashsoftware.deepSearcher2.searcher.matchers.StringMatcher;
/**
 * A string matcher that is implemented according to the Knuth-Morris-Pratt (KMP) algorithm
 */
public class KMPMatcher extends StringMatcher {
    private int[] next;
    public KMPMatcher(String s) {
        super(s);
    }
    private void calculateNext(String target) {
        int tLen = target.length();
        next = new int[tLen];
        next[0] = -1;
        int k = -1;
        int j = 0;
        while (j < tLen - 1) {
            if (k == -1 || target.charAt(j) == target.charAt(k)) {
                j++;
                k++;
                if (target.charAt(j) == target.charAt(k)) {
                    next[j] = next[k];
                } else {
                    next[j] = k;
                }
            } else {
                k = next[k];
            }
        }
    }
    @Override
    public int search(String target) {
        int sLen = string.length();
        int tLen = target.length();
        calculateNext(target);
        int i = 0, j = 0;
        while (i < sLen && j < tLen) {
            if (j == -1 || string.charAt(i) == target.charAt(j)) {
                i++;
                j++;
            } else {
                j = next[j];
            }
        }
        if (j == tLen) return i - j;
        else return -1;
    }
}
package trashsoftware.deepSearcher2.searcher.matchers.regularMatchers;
import trashsoftware.deepSearcher2.searcher.matchers.StringMatcher;
/**
 * A string matcher that is implemented by the naive algorithm.
 * <p>
 * This algorithm is strongly not-recommended.
 */
public class NaiveMatcher extends StringMatcher {
    public NaiveMatcher(String s) {
        super(s);
    }
    private static int naiveMatch(String string, String pattern) {
        if (pattern.length() > string.length()) return -1;
        for (int i = 0; i < string.length() - pattern.length() + 1; i++) {
            int j;
            for (j = 0; j < pattern.length(); j++) {
                if (string.charAt(i + j) != pattern.charAt(j)) break;
            }
            if (j == pattern.length()) return i;
        }
        return -1;
    }
    @Override
    public int search(String target) {
        return naiveMatch(string, target);
    }
}
package trashsoftware.deepSearcher2.searcher.matchers.regularMatchers;
import trashsoftware.deepSearcher2.searcher.matchers.StringMatcher;
public class NativeMatcher extends StringMatcher {
    public NativeMatcher(String s) {
        super(s);
    }
    @Override
    public int search(String target) {
        return string.indexOf(target);
    }
}
package trashsoftware.deepSearcher2.searcher.matchers.regularMatchers;
import trashsoftware.deepSearcher2.searcher.matchers.StringMatcher;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
/**
 * A string matcher that is implemented according to the "Sunday" algorithm
 */
public class SundayMatcher extends StringMatcher {
    /**
     * Reason for not using array: Unicode character
     */
    private Map<Character, Integer> indices;
    public SundayMatcher(String string) {
        super(string);
    }
    private void calculateIndices(String pat) {
        indices = new HashMap<>();
        int pLen = pat.length();
        for (int i = 0; i < pLen; i++) {
            indices.put(pat.charAt(i), i);
        }
    }
    @Override
    public int search(String pat) {
        calculateIndices(pat);
        int sLen = string.length();
        int pLen = pat.length();
        int s = 0;
        int end = sLen - pLen;
        while (s <= end) {
            int i;
            for (i = 0; i < pLen; i++) {
                if (string.charAt(s + i) != pat.charAt(i)) break;
            }
            if (i == pLen) return s;
            if (s == end) break;
            char next = string.charAt(s + pLen);
            Integer lastPos = Objects.requireNonNullElse(indices.get(next), -1);
            s += pLen - lastPos;
        }
        return -1;
    }
}
package trashsoftware.deepSearcher2.searcher.matchers;
/**
 * A class that stores a long text to be search.
 */
public abstract class StringMatcher {
    protected final String string;
    /**
     * Constructor.
     *
     * @param string the long string, which may be the file name or file content.
     */
    public StringMatcher(String string) {
        this.string = string;
    }
    /**
     * Returns the first occurrence position of {@code pattern} in {@code this.string}, {@code -1} if not found
     * <p>
     * Indexes are counted from 0.
     *
     * @param pattern the target string fragment
     * @return the first occurrence position of {@code pattern} in {@code this.string}, {@code -1} if not found
     */
    public abstract int search(String pattern);
}
package trashsoftware.deepSearcher2.searcher.matchers.wordMatchers;
import trashsoftware.deepSearcher2.searcher.matchers.StringMatcher;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
/**
 * A word matcher, implemented with hashing algorithm.
 */
public class HashedWordMatcher extends StringMatcher {
    private final Map<Integer, Set<String>> lengthMap = new HashMap<>();
    public HashedWordMatcher(String string) {
        super(string);
        splitToMap(string);
    }
    private void splitToMap(String s) {
        int sLen = s.length();
        StringBuilder wordBuilder = new StringBuilder();
        for (int i = 0; i < sLen; i++) {
            char c = s.charAt(i);
            if (WordSplitter.isWordChar(c)) {
                wordBuilder.append(c);
            } else if (wordBuilder.length() > 0) {
                String word = wordBuilder.toString();
                wordBuilder.setLength(0);
                putToMap(word);
            }
        }
        if (wordBuilder.length() > 0) putToMap(wordBuilder.toString());
    }
    private void putToMap(String word) {
        int wordLen = word.length();
        Set<String> listOfThisLen = lengthMap.computeIfAbsent(wordLen, k -> new HashSet<>());
        listOfThisLen.add(word);
    }
    @Override
    public int search(String pattern) {
        Set<String> listOfThisLen = lengthMap.get(pattern.length());
        if (listOfThisLen == null) return -1;
        return listOfThisLen.contains(pattern) ? 1 : -1;
    }
}
package trashsoftware.deepSearcher2.searcher.matchers.wordMatchers;
import trashsoftware.deepSearcher2.searcher.matchers.StringMatcher;
public class NaiveWordMatcher extends StringMatcher {
    private final String[] words;
    public NaiveWordMatcher(String string) {
        super(string);
        this.words = WordSplitter.split(string);
    }
    @Override
    public int search(String pattern) {
        int i = 0;
        for (String s : words) {
            if (s.equals(pattern)) {
                return i;
            }
            i += s.length() + 1;
        }
        return -1;
    }
}
package trashsoftware.deepSearcher2.searcher.matchers.wordMatchers;
import java.util.ArrayList;
import java.util.List;
class WordSplitter {
    static String[] split(String s) {
        List<String> list = new ArrayList<>();
        int sLen = s.length();
        StringBuilder wordBuilder = new StringBuilder();
        for (int i = 0; i < sLen; i++) {
            char c = s.charAt(i);
            if (isWordChar(c)) {
                wordBuilder.append(c);
            } else if (wordBuilder.length() > 0) {
                list.add(wordBuilder.toString());
                wordBuilder.setLength(0);
            }
        }
        if (wordBuilder.length() > 0) list.add(wordBuilder.toString());
        return list.toArray(new String[0]);
    }
    static boolean isWordChar(char c) {
        return Character.isAlphabetic(c) || Character.isDigit(c) || c == '_';
    }
}
package trashsoftware.deepSearcher2.searcher;
import trashsoftware.deepSearcher2.searcher.matchers.MatchMode;
import trashsoftware.deepSearcher2.util.Configs;
import java.io.File;
import java.util.*;
import java.util.regex.Pattern;
/**
 * A class that holds the current search preferences set by user.
 */
public class PrefSet {
    private static final Map<String, String> ESCAPES = Map.of(
            "\\0", "\0",
            "\\b", "\b",
            "\\n", "\n",
            "\\r", "\r",
            "\\f", "\f",
            "\\t", "\t"
    );
    private boolean matchAll;
    private List<File> searchDirs;
    private List<String> targets;
    private boolean fileName;
    private boolean dirName;
    private boolean matchCase;
    private boolean includePathName;
    private boolean showHidden;
    private boolean matchRegex;
    private boolean matchWord;
    private Set<String> extensions;  // null if not searching content
    private Algorithm.Regular matchingAlg;
    private Algorithm.Word wordMatchingAlg;
    private Algorithm.Regex regexMatchingAlg;
    private Set<String> excludedDirs;
    private Set<String> excludedFormats;
    private int maxSearchDepth;
    private boolean limitDepth;
    private boolean wholeContent;
    private boolean escapes;
    private int depthFirstIndicator = -1;  // -1 for not read, 0 for breadth first 1, for depth first
    /**
     * Private constructor, avoiding constructing from outside.
     * <p>
     * Please use {@code PrefSet.PrefSetBuilder} to create instances of this class.
     */
    private PrefSet() {
    }
    public List<File> getSearchDirs() {
        return searchDirs;
    }
    public Set<String> getExtensions() {
        return extensions;
    }
    /**
     * @return a list of all targets, if not {@code isCaseSensitive()}, all targets are in lower case already.
     */
    public List<String> getTargets() {
        return targets;
    }
    /**
     * @return {@code true} if match all, {@code false} if match any
     */
    public boolean isMatchAll() {
        return matchAll;
    }
    public boolean isCaseSensitive() {
        return matchCase;
    }
    /**
     * @return is searching directory names
     */
    public boolean isDirName() {
        return dirName;
    }
    public boolean isFileName() {
        return fileName;
    }
    /**
     * Whether to search full path name instead of the last name of a file.
     * <p>
     * For example, "C:\Program Files\Java" matches "Files\Java" only when this method returns true.
     *
     * @return is including full path names
     */
    public boolean isIncludePathName() {
        return includePathName;
    }
    public boolean notShowHidden() {
        return !showHidden;
    }
    /**
     * @return the maximum traversal depth
     */
    public int getMaxSearchDepth() {
        return maxSearchDepth;
    }
    /**
     * @return whether to limit search depth
     */
    public boolean isLimitDepth() {
        return limitDepth;
    }
    /**
     * Whether to search every file's content as a whole string, not line-by-line.
     *
     * @return whether to search every file's content as a whole string, not line-by-line
     */
    public boolean isWholeContent() {
        return wholeContent;
    }
    /**
     * Whether to search escape characters, e.g. \n, \t, \b, \r
     *
     * @return {@code true} if search escape characters
     */
    public boolean isEscapes() {
        return escapes;
    }
    public MatchMode getMatchMode() {
        if (matchWord) return MatchMode.WORD;
        else if (matchRegex) return MatchMode.REGEX;
        else return MatchMode.NORMAL;
    }
    public boolean isDepthFirst() {
        if (depthFirstIndicator == -1) {
            depthFirstIndicator = Configs.getConfigs().isDepthFirst() ? 1 : 0;
        }
        return depthFirstIndicator == 1;
    }
    public Algorithm.Regular getMatchingAlgorithm() {
        if (matchingAlg == null) {
            matchingAlg = Configs.getConfigs().getCurrentSearchingAlgorithm();
        }
        return matchingAlg;
    }
    public Algorithm.Word getWordMatchingAlgorithm() {
        if (wordMatchingAlg == null) {
            wordMatchingAlg = Configs.getConfigs().getCurrentWordSearchingAlgorithm();
        }
        return wordMatchingAlg;
    }
    public Algorithm.Regex getRegexAlgorithm() {
        if (regexMatchingAlg == null) {
            regexMatchingAlg = Configs.getConfigs().getCurrentRegexSearchingAlgorithm();
        }
        return regexMatchingAlg;
    }
    Set<String> getExcludedDirs() {
        if (excludedDirs == null) excludedDirs = Configs.getConfigs().getAllExcludedDirs();
        return excludedDirs;
    }
    Set<String> getExcludedFormats() {
        if (excludedFormats == null) excludedFormats = Configs.getConfigs().getAllExcludedFormats();
        return excludedFormats;
    }
    private static List<String> replaceEscapes(List<String> targets) {
        List<String> result = new ArrayList<>();
        for (String s : targets) {
            for (Map.Entry<String, String> entry : ESCAPES.entrySet()) {
                s = s.replace(entry.getKey(), entry.getValue());
            }
            result.add(s);
        }
        return result;
    }
    public static class PrefSetBuilder {
        private final PrefSet prefSet = new PrefSet();
        public PrefSetBuilder setMatchAll(boolean matchAll) {
            prefSet.matchAll = matchAll;
            return this;
        }
        public PrefSetBuilder caseSensitive(boolean matchCase) {
            prefSet.matchCase = matchCase;
            return this;
        }
        public PrefSetBuilder searchFileName(boolean searchFileName) {
            prefSet.fileName = searchFileName;
            return this;
        }
        public PrefSetBuilder searchDirName(boolean searchDirName) {
            prefSet.dirName = searchDirName;
            return this;
        }
        public PrefSetBuilder matchWord(boolean matchWord) {
            prefSet.matchWord = matchWord;
            return this;
        }
        public PrefSetBuilder matchRegex(boolean matchRegex) {
            prefSet.matchRegex = matchRegex;
            return this;
        }
        public PrefSetBuilder directSetMatchMode(MatchMode matchMode) {
            if (matchMode == MatchMode.NORMAL) {
                prefSet.matchWord = false;
                prefSet.matchRegex = false;
            } else if (matchMode == MatchMode.WORD) {
                prefSet.matchWord = true;
                prefSet.matchRegex = false;
            } else if (matchMode == MatchMode.REGEX) {
                prefSet.matchWord = false;
                prefSet.matchRegex = true;
            } else {
                throw new RuntimeException("No such match mode");
            }
            return this;
        }
        /**
         * Sets up the directories to search.
         * <p>
         * Precondition: input list contains no duplicate files.
         * This method removes the children directories of any directories of other directories, if there
         * is no searching depth limit.
         * <p>
         * Reason for not removing children directories when there exists depth limit:
         * Consider two directories, "A" and "A/B". If the target file is "A/B/x.txt" and the depth limit is 1,
         * removing "A/B" would result in the absence of "A/B/x.txt".
         *
         * @param searchDirs all unique directories to search
         * @return this builder
         */
        public PrefSetBuilder setSearchDirs(List<File> searchDirs) {
            prefSet.limitDepth = Configs.getConfigs().isLimitDepth();
            prefSet.maxSearchDepth = Configs.getConfigs().getMaxSearchDepth();
            if (prefSet.limitDepth) {
                prefSet.searchDirs = new ArrayList<>(searchDirs);
                return this;
            }
            // uses a trie-like data structure to remove all children directories of added directories
            FileTree fileTree = new FileTree(searchDirs);
            prefSet.searchDirs = fileTree.getAllNoDup();
            return this;
        }
        public PrefSetBuilder setTargets(List<String> targets) {
            prefSet.targets = targets;
            return this;
        }
        public PrefSetBuilder setExtensions(Set<String> extensions) {
            prefSet.extensions = extensions;
            return this;
        }
        /**
         * Builds a new {@code PrefSet} with all options specified and some other options reads from config.
         *
         * @return a new {@code PrefSet}
         * @throws SearchTargetNotSetException if search target is not set
         * @throws SearchDirNotSetException    if no search directory is set
         * @throws SearchPrefNotSetException   if nothing to search
         */
        public PrefSet build()
                throws SearchTargetNotSetException, SearchDirNotSetException, SearchPrefNotSetException {
            if (prefSet.targets == null || prefSet.targets.isEmpty() || areTargetsAllEmpty()) {
                throw new SearchTargetNotSetException("No searching targets");
            }
            if (prefSet.searchDirs == null || prefSet.searchDirs.isEmpty()) {
                throw new SearchDirNotSetException("No searching directories");
            }
            if (noPrefSelected()) {
                throw new SearchPrefNotSetException("No searching things");
            }
            if (!prefSet.matchCase) {  // if not match case, convert to all lower case
                for (int i = 0; i < prefSet.targets.size(); i++) {
                    prefSet.targets.set(i, prefSet.targets.get(i).toLowerCase());
                }
            }
            prefSet.showHidden = Configs.getConfigs().isShowHidden();
            prefSet.includePathName = Configs.getConfigs().isIncludePathName();
            prefSet.wholeContent = Configs.getConfigs().isWholeContent();
            prefSet.escapes = Configs.getConfigs().isSearchEscapes();
            // depth limits are set in 'addSearchDirs'
            if (prefSet.escapes) {
                prefSet.targets = replaceEscapes(prefSet.targets);
            }
            return prefSet;
        }
        private boolean noPrefSelected() {
            return !prefSet.fileName &&
                    !prefSet.dirName &&
                    (prefSet.extensions == null || prefSet.extensions.isEmpty());
        }
        private boolean areTargetsAllEmpty() {
            for (String s : prefSet.targets) {
                if (s.length() > 0) return false;
            }
            return true;
        }
    }
    private static class FileTree {
        private final FileTreeNode root = new FileTreeNode();
        private FileTree(List<File> files) {
            for (File f : files) add(f);
        }
        private void add(File file) {
            String[] parts = file.getAbsolutePath().split(Pattern.quote(File.separator));
            FileTreeNode cur = root;
            for (String part : parts) {
                FileTreeNode node = cur.children.get(part);
                if (node == null) {
                    node = new FileTreeNode();
                    cur.children.put(part, node);
                }
                cur = node;
            }
            cur.isEnd = true;
        }
        /**
         * @return returns all outermost files that are real paths, i.e. marked as "isEnd=true"
         */
        private List<File> getAllNoDup() {
            List<File> res = new ArrayList<>();
            root.fillCompleteFile(res, "", "");
            return res;
        }
        @Override
        public String toString() {
            FileTreeNode.spaceCount = 0;
            return root.toString(null);
        }
    }
    /**
     * A trie-like data structure, recording an added directory.
     */
    private static class FileTreeNode {
        private static int spaceCount;  // only used for "toString"
        private final Map<String, FileTreeNode> children = new HashMap<>();
        private boolean isEnd = false;  // whether this node represents a real file
        private void fillCompleteFile(List<File> files, String nameOfThis, String added) {
            String thisPath = added + nameOfThis + File.separator;
            if (isEnd) files.add(new File(thisPath));
            else for (Map.Entry<String, FileTreeNode> entry : children.entrySet())
                entry.getValue().fillCompleteFile(files, entry.getKey(), thisPath);
        }
        private String toString(String nameOfThis) {
            StringBuilder sb = new StringBuilder()
                    .append(" ".repeat(spaceCount))
                    .append(nameOfThis)
                    .append(" (")
                    .append(isEnd)
                    .append(")")
                    .append('\n');
            spaceCount += 2;
            for (Map.Entry<String, FileTreeNode> entry : children.entrySet()) {
                sb.append(entry.getValue().toString(entry.getKey()));
            }
            spaceCount -= 2;
            return sb.toString();
        }
    }
}
package trashsoftware.deepSearcher2.searcher;
/**
 * Indicates no searching directory is selected.
 */
public class SearchDirNotSetException extends Exception {
    SearchDirNotSetException(String message) {
        super(message);
    }
}
package trashsoftware.deepSearcher2.searcher;
import javafx.beans.property.ReadOnlyIntegerProperty;
import javafx.beans.property.ReadOnlyIntegerWrapper;
import javafx.collections.ObservableList;
import trashsoftware.deepSearcher2.guiItems.ResultItem;
import trashsoftware.deepSearcher2.searcher.contentSearchers.*;
import trashsoftware.deepSearcher2.searcher.matchers.MatcherFactory;
import trashsoftware.deepSearcher2.searcher.matchers.StringMatcher;
import trashsoftware.deepSearcher2.util.Configs;
import trashsoftware.deepSearcher2.util.EventLogger;
import trashsoftware.deepSearcher2.util.Util;
import java.io.File;
import java.lang.reflect.InvocationTargetException;
import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
/**
 * The core of searching.
 * <p>
 * This class mainly does the file system traversal and allocate proper content searcher.
 */
public class Searcher {
    private static final Map<String, Class<? extends ContentSearcher>> FORMAT_MAP = Map.of(
            "pdf", PdfSearcher.class,
            "doc", DocSearcher.class,
            "docx", DocxSearcher.class,
            "ppt", PptSearcher.class,
            "pptx", PptxSearcher.class,
            "xls", XlsSearcher.class,
            "xlsx", XlsxSearcher.class
    );
    private final Map<String, String> customFormats;
    private final PrefSet prefSet;
    private final ExecutorService contentService;
    private final ReadOnlyIntegerWrapper resultCountWrapper = new ReadOnlyIntegerWrapper();
    private final ObservableList<ResultItem> tableList;
    private final Map<File, ResultItem> resultFilesMap = new HashMap<>();
    private final ResourceBundle bundle;
    private final ResourceBundle fileTypeBundle;
    private final MatcherFactory nameMatcherFactory;
    private final MatcherFactory contentMatcherFactory;
    private boolean searching = true;
    /**
     * Constructor.
     *
     * @param prefSet        the pref set, recording all search preferences and is immutable.
     * @param tableList      the javafx list of the result {@code TableView}
     * @param bundle         language bundle
     * @param fileTypeBundle type bundle
     * @param customFormats  all custom formats, immutable after
     */
    public Searcher(PrefSet prefSet,
                    ObservableList<ResultItem> tableList,
                    ResourceBundle bundle,
                    ResourceBundle fileTypeBundle,
                    Map<String, String> customFormats) {
        this.prefSet = prefSet;
        this.tableList = tableList;
        this.bundle = bundle;
        this.fileTypeBundle = fileTypeBundle;
        this.nameMatcherFactory = MatcherFactory.createFactoryByPrefSet(prefSet);
        this.contentMatcherFactory = MatcherFactory.createFactoryByPrefSet(prefSet);
        // This is wrapped by a new map to avoid situations that the user modifies custom formats while searching
        this.customFormats = new HashMap<>(customFormats);
        contentService = Executors.newFixedThreadPool(Configs.getConfigs().getCurrentCpuThreads());
    }
    /**
     * Start searching
     */
    public void search() {
        boolean depthFirst = prefSet.isDepthFirst();
        if (depthFirst) {
            for (File f : prefSet.getSearchDirs()) {
                depthFirstSearch(f);
            }
        } else {
            for (File f : prefSet.getSearchDirs()) {
                breadthFirstSearch(f);
            }
        }
        contentService.shutdown();
        try {
            if (!contentService.awaitTermination(Long.MAX_VALUE, TimeUnit.MILLISECONDS)) {
                EventLogger.log("292,471,208 years have passed! The sun has brightened another 3%!");
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    /**
     * Interrupt the search process.
     * <p>
     * This method does not shut down the search process immediately. Instead, it marks this searcher as stopped.
     * All subsequent file traversal and file reading tasks are cancelled.
     */
    public void stop() {
        searching = false;
        contentService.shutdownNow();
    }
    private void depthFirstSearch(File rootFile) {
        boolean notShowHidden = prefSet.notShowHidden();
        int maxDepth = prefSet.isLimitDepth() ? prefSet.getMaxSearchDepth() : Integer.MAX_VALUE;
        Deque<DepthFile> stack = new ArrayDeque<>();
        stack.addLast(new DepthFile(rootFile, 0));
        while (!stack.isEmpty()) {
            if (!searching) return;
            DepthFile file = stack.removeLast();
            if (notShowHidden && file.file.isHidden()) continue;
            if (file.file.isDirectory()) {
                // Check if this directory is excluded
                if (prefSet.getExcludedDirs().contains(file.file.getAbsolutePath())) continue;
                // Check dir is selected
                if (prefSet.isDirName()) {
                    matchName(file.file);
                }
                if (file.depth >= maxDepth) continue;
                File[] subFiles = file.file.listFiles();
                if (subFiles == null) continue;
                for (int i = subFiles.length - 1; i >= 0; i--) {
                    stack.addLast(new DepthFile(subFiles[i], file.depth + 1));
                }
            } else {
                searchOneFile(file.file);
            }
        }
    }
    private void breadthFirstSearch(File rootFile) {
        boolean notShowHidden = prefSet.notShowHidden();
        int maxDepth = prefSet.isLimitDepth() ? prefSet.getMaxSearchDepth() : Integer.MAX_VALUE;
        Deque<DepthFile> stack = new ArrayDeque<>();
        stack.addLast(new DepthFile(rootFile, 0));
        while (!stack.isEmpty()) {
            if (!searching) return;
            DepthFile file = stack.removeFirst();
            if (notShowHidden && file.file.isHidden()) continue;
            if (file.file.isDirectory()) {
                // Check if this directory is excluded
                if (prefSet.getExcludedDirs().contains(file.file.getAbsolutePath())) continue;
                // Check dir is selected
                if (prefSet.isDirName()) {
                    matchName(file.file);
                }
                if (file.depth >= maxDepth) continue;
                File[] subFiles = file.file.listFiles();
                if (subFiles == null) continue;
                for (File f : subFiles) {
                    stack.addLast(new DepthFile(f, file.depth + 1));
                }
            } else {
                searchOneFile(file.file);
            }
        }
    }
    private void searchOneFile(File file) {
        // Check if this format is excluded
        if (prefSet.getExcludedFormats().contains(Util.getFileExtension(file.getName()))) return;
        // check file name is selected
        if (prefSet.isFileName()) {
            matchName(file);
        }
        // check file content is selected
        if (prefSet.getExtensions() != null) {
            matchFileContent(file);
        }
    }
    private void matchName(File file) {
        if (prefSet.isMatchAll()) matchNameAll(file);
        else matchNameAny(file);
    }
    private void matchNameAll(File file) {
        String name = getSearchingFileName(file);
        StringMatcher matcher = nameMatcherFactory.createMatcher(name);
        for (String target : prefSet.getTargets()) {
            if (matcher.search(target) < 0) return;
        }
        addNameResult(file);
    }
    private void matchNameAny(File file) {
        String name = getSearchingFileName(file);
        StringMatcher matcher = nameMatcherFactory.createMatcher(name);
        for (String target : prefSet.getTargets()) {
            if (matcher.search(target) >= 0) {
                addNameResult(file);
                return;
            }
        }
    }
    private void matchFileContent(File file) {
        String ext = Util.getFileExtension(file.getName());
        if (prefSet.getExtensions().contains(ext)) {
            ContentSearcher searcher;
            if (FORMAT_MAP.containsKey(ext)) {
                try {
                    searcher = FORMAT_MAP.get(ext)
                            .getDeclaredConstructor(File.class, MatcherFactory.class, boolean.class)
                            .newInstance(file, contentMatcherFactory, prefSet.isCaseSensitive());
                } catch (InvocationTargetException |
                        NoSuchMethodException |
                        InstantiationException |
                        IllegalAccessException e) {
                    throw new InvalidClassException("Unexpected file content searcher. ", e);
                }
            } else {
                searcher = new PlainTextSearcher(file, contentMatcherFactory, prefSet.isCaseSensitive());
            }
            contentService.execute(new SearchContentTask(file, searcher));
        }
    }
    private String getSearchingFileName(File file) {
        if (prefSet.isIncludePathName()) {
            if (prefSet.isCaseSensitive()) return file.getAbsolutePath();
            else return file.getAbsolutePath().toLowerCase();
        } else {
            if (prefSet.isCaseSensitive()) return file.getName();
            else return file.getName().toLowerCase();
        }
    }
    private void updateResultCount() {
        resultCountWrapper.setValue(tableList.size());
    }
    private synchronized void addContentResult(File file, ContentResult csr) {
        // check if previous some result is already added
        // This situation occurs when this file is already matched by name successfully
        ResultItem item = resultFilesMap.get(file);
        if (item != null) {
            item.setContentRes(csr);
        } else {
            ResultItem resultItem = ResultItem.createContentMatch(file, bundle, fileTypeBundle, csr, customFormats);
            tableList.add(resultItem);
            resultFilesMap.put(file, resultItem);
            updateResultCount();
        }
    }
    private void addNameResult(File file) {
        // check duplicate
        // duplicate may happens when a depth limit is set, so prefSet does not remove parent-children directories.
        if (!resultFilesMap.containsKey(file)) {
            ResultItem resultItem = ResultItem.createNameMatch(file, bundle, fileTypeBundle, customFormats);
            tableList.add(resultItem);
            resultFilesMap.put(file, resultItem);
            updateResultCount();
        }
    }
    public boolean isNormalFinish() {
        return searching;
    }
    public ReadOnlyIntegerProperty resultCountProperty() {
        return resultCountWrapper;
    }
    private static class DepthFile {
        private final int depth;
        private final File file;
        DepthFile(File file, int depth) {
            this.file = file;
            this.depth = depth;
        }
        @Override
        public String toString() {
            return "DepthFile{" + file.getAbsolutePath() + " at depth " + depth + '}';
        }
    }
    /**
     * A class that runs file content searching in background.
     */
    private class SearchContentTask implements Runnable {
        private final File file;
        private final ContentSearcher searcher;
        private SearchContentTask(File file, ContentSearcher searcher) {
            this.file = file;
            this.searcher = searcher;
        }
        @Override
        public void run() {
            ContentResult result;
            if (prefSet.isWholeContent()) {
                if (prefSet.isMatchAll()) result = searcher.searchAllWhole(prefSet.getTargets());
                else result = searcher.searchAnyWhole(prefSet.getTargets());
            } else {
                if (prefSet.isMatchAll()) result = searcher.searchAll(prefSet.getTargets());
                else result = searcher.searchAny(prefSet.getTargets());
            }
            if (result != null) addContentResult(file, result);
        }
    }
}
package trashsoftware.deepSearcher2.searcher;
/**
 * Indicator of no pref checkboxes are checked.
 */
public class SearchPrefNotSetException extends Exception {
    SearchPrefNotSetException(String msg) {
        super(msg);
    }
}
package trashsoftware.deepSearcher2.searcher;
/**
 * Indicates no search target is inputted
 */
public class SearchTargetNotSetException extends Exception {
    SearchTargetNotSetException(String message) {
        super(message);
    }
}
package trashsoftware.deepSearcher2.util;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import java.io.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;
/**
 * This class loads and saves user's cache to the disk periodically.
 */
public class Cache {
    public static final String FORMATS_KEY = "formats";
    public static final String OPENED_DIRS_KEY = "openedDirs";
    static final String CACHE_DIR = "cache";
    private static final String COMMON_CACHE_NAME = CACHE_DIR + File.separator + "cache.json";
    /**
     * Time interval in mills between two save tasks that save cache in ram to disk
     */
    private static final long AUTO_SAVE_INTERVAL = 3000;
    private static Cache activeCache;
    private final Timer autoSave;
    private final List<CacheObservable> cacheObservables = new ArrayList<>();
    private JSONObject root;
    private Cache(List<CacheObservable> cacheObservables) {
        loadFromDisk();
        autoSave = new Timer();
        autoSave.schedule(new AutoSaveTask(), AUTO_SAVE_INTERVAL, AUTO_SAVE_INTERVAL);
        this.cacheObservables.addAll(cacheObservables);
    }
    /**
     * Gets the active cache loader.
     * <p>
     * The active cache loader is guaranteed unique.
     *
     * @return the current active cache loader
     */
    public static Cache getCache() {
        return activeCache;
    }
    /**
     * Starts a new {@code Cache} and sets it as active.
     * <p>
     * This method stops the previous active cache loader, if there was.
     *
     * @param cacheObservables the gui pages that supports cache.
     */
    public static void startCache(List<CacheObservable> cacheObservables) {
        if (activeCache != null) {
            activeCache.stop();
        }
        activeCache = new Cache(cacheObservables);
    }
    public static void startCache() {
        startCache(List.of());
    }
    /**
     * Terminates the current active cache loader.
     */
    public static void stopCache() {
        if (activeCache != null) {
            activeCache.stop();
            activeCache = null;
        }
    }
    /**
     * Clear cache stored on the disk.
     */
    public static void clearCache() {
        List<CacheObservable> cos = activeCache.cacheObservables;
        activeCache.stop();
        Configs.deleteFileByName(COMMON_CACHE_NAME);
        activeCache = new Cache(cos);
        for (CacheObservable co : cos) {
            co.loadFromCache(activeCache);
        }
    }
    /**
     * Terminates this cache loader and stores all cache in ram to disk.
     */
    public void stop() {
        autoSave.cancel();
        saveToDisk();
    }
    /**
     * Adds a new gui page that supports cache.
     *
     * @param cacheObservable the gui page that supports cache to be added
     */
    public void addObservable(CacheObservable cacheObservable) {
        cacheObservables.add(cacheObservable);
    }
    private synchronized void saveToDisk() {
        for (CacheObservable co : cacheObservables) {
            co.putCache(root);
        }
        Configs.createDirsIfNotExist();
        String s = root.toString(2);
        FileWriter fw = null;
        try {
            fw = new FileWriter(COMMON_CACHE_NAME);
            fw.write(s);
            fw.flush();
        } catch (IOException e) {
            //
        } finally {
            if (fw != null) {
                try {
                    fw.close();
                } catch (IOException ioException) {
                    ioException.printStackTrace();
                }
            }
        }
    }
    private void loadFromDisk() {
        BufferedReader br = null;
        try {
            br = new BufferedReader(new FileReader(COMMON_CACHE_NAME));
            StringBuilder builder = new StringBuilder();
            String line;
            while ((line = br.readLine()) != null) {
                builder.append(line);
            }
            root = new JSONObject(builder.toString());
        } catch (FileNotFoundException e) {
            root = new JSONObject();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (br != null) {
                try {
                    br.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    public String getStringCache(String key) {
        if (root.has(key)) {
            try {
                return root.getString(key);
            } catch (JSONException e) {
                //
            }
        }
        return null;
    }
    public boolean getBooleanCache(String key, boolean defaultValue) {
        if (root.has(key)) {
            try {
                return root.getBoolean(key);
            } catch (JSONException e) {
                //
            }
        }
        return defaultValue;
    }
    public JSONArray getArrayCache(String key) {
        if (root.has(key)) {
            try {
                return root.getJSONArray(key);
            } catch (JSONException e) {
                //
            }
        }
        JSONArray array = new JSONArray();
        root.put(key, array);
        return array;
    }
    private class AutoSaveTask extends TimerTask {
        @Override
        public void run() {
            saveToDisk();
        }
    }
}
package trashsoftware.deepSearcher2.util;
import org.json.JSONObject;
/**
 * An interface of gui classes that periodically saves cache to disk.
 */
public interface CacheObservable {
    /**
     * Saves cache of gui to the saver
     *
     * @param rootObject target json
     */
    void putCache(JSONObject rootObject);
    /**
     * Loads saved cache to the gui
     *
     * @param cache saved cache from last time
     */
    void loadFromCache(Cache cache);
}
package trashsoftware.deepSearcher2.util;
import javafx.scene.Scene;
import javafx.scene.text.Font;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import trashsoftware.deepSearcher2.guiItems.HistoryItem;
import trashsoftware.deepSearcher2.searcher.*;
import trashsoftware.deepSearcher2.searcher.matchers.MatchMode;
import java.io.*;
import java.net.MalformedURLException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.zip.CRC32;
public class Configs {
    private static final String USER_DATA_DIR = "userData";
    private static final String CONFIG_FILE_NAME = USER_DATA_DIR + File.separator + "config.cfg";
    private static final String EXCLUDED_DIRS_NAME = USER_DATA_DIR + File.separator + "excludedDirs.cfg";
    private static final String EXCLUDED_FORMATS_NAME = USER_DATA_DIR + File.separator + "excludedFormats.cfg";
    private static final String CUSTOM_FORMATS_NAME = USER_DATA_DIR + File.separator + "customFormats.cfg";
    private static final String CUSTOM_CSS = USER_DATA_DIR + File.separator + "style.css";
    private static final String HISTORY_DIR = USER_DATA_DIR + File.separator + "history";
    /**
     * Time interval in mills between two save tasks that save changed configs in ram to disk
     */
    private static final long AUTO_SAVE_INTERVAL = 5000;
    private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd,HH-mm-ss-SSS");
    private static Configs activeConfig;
    private final Timer autoSave;
    private Map<String, String> configMap;
    private Set<String> excludedDirs;
    private Set<String> excludedFmts;
    private Map<String, String> customFmts;
    private long excludedDirsChecksum;
    private long excludedFmtsChecksum;
    private long customFmtsChecksum;
    private Configs() {
        loadAll();
        autoSave = new Timer();
        autoSave.schedule(new AutoSaveTask(), AUTO_SAVE_INTERVAL, AUTO_SAVE_INTERVAL);
    }
    /**
     * Starts running a config loader and terminate the previous one, if existed.
     */
    public static void startConfig() {
        if (activeConfig != null) {
            activeConfig.stop();
        }
        activeConfig = new Configs();
    }
    /**
     * Terminates the current running config loader.
     * <p>
     * This static method should be called before the program exits. Otherwise, a background saver might keep running.
     */
    public static void stopConfig() {
        if (activeConfig != null) {
            activeConfig.stop();
            activeConfig = null;
        }
    }
    /**
     * @return the current running config loader
     */
    public static Configs getConfigs() {
        return activeConfig;
    }
    /**
     * Returns a list containing all supported locales.
     *
     * @return a list containing all supported locales
     */
    public static List<NamedLocale> getAllLocales() {
        List<NamedLocale> locales = new ArrayList<>();
        ResourceBundle resourceBundle = ResourceBundle.getBundle("trashsoftware.deepSearcher2.bundles.Languages");
        Enumeration<String> keys = resourceBundle.getKeys();
        while (keys.hasMoreElements()) {
            String key = keys.nextElement();
            String[] lanLocale = key.split("_");
            NamedLocale namedLocale = new NamedLocale(lanLocale[0], lanLocale[1], resourceBundle.getString(key));
            locales.add(namedLocale);
        }
        return locales;
    }
    /**
     * Returns a list of history records, ranked from newest to oldest.
     *
     * @return a list of histories, ranked from newest to oldest
     */
    public static List<HistoryItem> getAllHistory() {
        List<HistoryItem> list = new ArrayList<>();
        createDirsIfNotExist();
        File historyDir = new File(HISTORY_DIR);
        for (File his : Objects.requireNonNull(historyDir.listFiles())) {
            try (BufferedReader reader = new BufferedReader(new FileReader(his))) {
                StringBuilder builder = new StringBuilder();
                String line;
                while ((line = reader.readLine()) != null) {
                    builder.append(line);
                }
                Date date = DATE_FORMAT.parse(his.getName());
                JSONObject jsonObject = new JSONObject(builder.toString());
                PrefSet prefSet = toPrefSet(jsonObject, his.getName());
                if (prefSet == null) continue;
                HistoryItem historyItem = new HistoryItem(prefSet, date);
                list.add(historyItem);
            } catch (IOException e) {
                e.printStackTrace();
                EventLogger.log(e);
            } catch (JSONException | ParseException e) {
                //
            }
        }
        Collections.reverse(list);
        return list;
    }
    public static void clearAllHistory() {
        File dir = new File(HISTORY_DIR);
        for (File file : Objects.requireNonNull(dir.listFiles())) {
            if (!file.delete()) {
                System.err.println("Failed to delete " + file.getAbsolutePath());
                EventLogger.log("Failed to delete " + file.getAbsolutePath());
            }
        }
    }
    static void deleteFileByName(String path) {
        File file = new File(path);
        if (!file.delete()) {
            System.err.println("Failed to delete '" + path + "'!");
            EventLogger.log("Failed to delete '" + path + "'!");
        }
    }
    public static void addHistory(PrefSet historyItem) {
        JSONObject object = toJsonObject(historyItem);
        String fileName = HISTORY_DIR + File.separator + DATE_FORMAT.format(new Date()) + ".json";
        try (BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(fileName))) {
            bufferedWriter.write(object.toString(2));
            bufferedWriter.flush();
        } catch (IOException e) {
            e.printStackTrace();
            EventLogger.log(e);
        }
    }
    private static JSONObject toJsonObject(PrefSet historyItem) {
        JSONObject root = new JSONObject();
        root.put("searchFileName", historyItem.isFileName());
        root.put("includePathName", historyItem.isIncludePathName());
        root.put("matchCase", historyItem.isCaseSensitive());
        root.put("matchMode", historyItem.getMatchMode().name());
        root.put("searchContent", historyItem.getExtensions() != null);
        root.put("searchDirName", historyItem.isDirName());
        root.put("matchAll", historyItem.isMatchAll());
        JSONArray dirs = new JSONArray(historyItem.getSearchDirs());
        JSONArray patterns = new JSONArray(historyItem.getTargets());
        JSONArray extensions = new JSONArray(historyItem.getExtensions());
        root.put("dirs", dirs);
        root.put("patterns", patterns);
        root.put("extensions", extensions);
        return root;
    }
    private static PrefSet toPrefSet(JSONObject root, String fileName) {
        List<File> dirs = new ArrayList<>();
        for (Object s : root.getJSONArray("dirs")) dirs.add(new File((String) s));
        List<String> patterns = new ArrayList<>();
        for (Object p : root.getJSONArray("patterns")) patterns.add((String) p);
        Set<String> extensions = new HashSet<>();
        for (Object e : root.getJSONArray("extensions")) extensions.add((String) e);
        try {
            return new PrefSet.PrefSetBuilder()
                    .searchFileName(root.getBoolean("searchFileName"))
                    .caseSensitive(root.getBoolean("matchCase"))
                    .directSetMatchMode(MatchMode.valueOf(root.getString("matchMode")))
                    .searchDirName(root.getBoolean("searchDirName"))
                    .setMatchAll(root.getBoolean("matchAll"))
                    .setSearchDirs(dirs)
                    .setTargets(patterns)
                    .setExtensions(root.getBoolean("searchContent") ? extensions : null)
                    .build();
        } catch (SearchTargetNotSetException | SearchDirNotSetException | SearchPrefNotSetException e) {
            // This would never happen
            System.err.println("Failed to load " + fileName);
            return null;
        }
    }
    private static Map<String, String> readMapFile(String fileName) {
        Map<String, String> map = new HashMap<>();
        try (BufferedReader br = new BufferedReader(new FileReader(fileName))) {
            String line;
            while ((line = br.readLine()) != null) {
                String[] keyValue = line.split("=");
                if (keyValue.length == 1) {
                    map.put(keyValue[0], "");
                } else if (keyValue.length == 2) {
                    map.put(keyValue[0], keyValue[1]);
                }
            }
        } catch (FileNotFoundException e) {
            writeMapFile(fileName, map);
        } catch (IOException e) {
            e.printStackTrace();
            EventLogger.log(e);
        }
        return map;
    }
    private static void writeMapFile(String fileName, Map<String, String> map) {
        try (BufferedWriter bw = new BufferedWriter(new FileWriter(fileName))) {
            createDirsIfNotExist();
            for (Map.Entry<String, String> entry : map.entrySet()) {
                String line = entry.getKey() + "=" + entry.getValue() + '\n';
                bw.write(line);
            }
            bw.flush();
        } catch (IOException e) {
            e.printStackTrace();
            EventLogger.log(e);
        }
    }
    private static Set<String> readListFile(String fileName) {
        Set<String> set = new HashSet<>();
        try (BufferedReader br = new BufferedReader(new FileReader(fileName))) {
            String line;
            while ((line = br.readLine()) != null) {
                set.add(line);
            }
        } catch (FileNotFoundException e) {
            writeListFile(fileName, set);
        } catch (IOException e) {
            e.printStackTrace();
            EventLogger.log(e);
        }
        return set;
    }
    private static void writeListFile(String fileName, Collection<String> set) {
        createDirsIfNotExist();
        try (BufferedWriter bw = new BufferedWriter(new FileWriter(fileName))) {
            for (String s : set) {
                bw.write(s);
                bw.write('\n');
            }
            bw.flush();
        } catch (IOException e) {
            e.printStackTrace();
            EventLogger.log(e);
        }
    }
    static void createDirsIfNotExist() {
        File cache = new File(Cache.CACHE_DIR);
        if (!cache.exists()) {
            if (!cache.mkdirs()) {
                System.err.println("Cannot create directory 'cache'");
                EventLogger.log("Cannot create directory 'cache'");
            }
        }
        File userData = new File(USER_DATA_DIR);
        if (!userData.exists()) {
            if (!userData.mkdirs()) {
                System.err.println("Cannot create directory 'userData'");
                EventLogger.log("Cannot create directory 'userData'");
            }
        }
        File history = new File(HISTORY_DIR);
        if (!history.exists()) {
            if (!history.mkdirs()) {
                System.err.println("Cannot create directory 'userData/history'");
                EventLogger.log("Cannot create directory 'userData'");
            }
        }
    }
    /**
     * Returns the current using locale.
     *
     * @return the current using locale
     */
    public Locale getCurrentLocale() {
        String localeName = getConfig("locale");
        if (localeName == null) {
            return new Locale("zh", "CN");
        } else {
            String[] lanCountry = localeName.split("_");
            return new Locale(lanCountry[0], lanCountry[1]);
        }
    }
    public void stop() {
        autoSave.cancel();
        saveToDisk();
    }
    public void applyCustomFont(Scene scene) {
        String fontFamily = getCustomFont();
        if (fontFamily == null) fontFamily = Font.getDefault().getFamily();
        int fontSize = getFontSize(12);
        String content = String.format(
                ".root {\n    -fx-font-family: %s;\n    -fx-font-size: %dpx;\n}",
                fontFamily,
                fontSize);
        try (FileWriter fw = new FileWriter(CUSTOM_CSS)) {
            fw.write(content);
            fw.flush();
        } catch (IOException e) {
            e.printStackTrace();
            EventLogger.log(e);
        }
        try {
            scene.getStylesheets().add(new File(CUSTOM_CSS).toURI().toURL().toExternalForm());
        } catch (MalformedURLException e) {
            e.printStackTrace();
            EventLogger.log(e);
        }
    }
    public String getCustomFont() {
        return getConfig("font");
    }
    public int getFontSize(int defaultValue) {
        return getInt("fontSize", defaultValue);
    }
    public boolean isWholeContent() {
        return getBoolean("wholeContent");
    }
    public boolean isSearchEscapes() {
        return getBoolean("escapes");
    }
    public boolean isUseCustomFont() {
        return getBoolean("useCustomFont");
    }
    public void setUseCustomFont(boolean value, String customFont, int fontSize) {
        writeConfigs(
                "useCustomFont", String.valueOf(value),
                "font", customFont,
                "fontSize", String.valueOf(fontSize));
    }
    public boolean isLimitDepth() {
        return getBoolean("limitDepth");
    }
    /**
     * Sets whether to limit search depth.
     *
     * @param limitDepth whether to limit search depth
     */
    public void setLimitDepth(boolean limitDepth) {
        writeConfig("limitDepth", String.valueOf(limitDepth));
    }
    /**
     * @return the max traversal depth
     */
    public int getMaxSearchDepth() {
        return getInt("maxDepth", 5);
    }
    /**
     * @param searchDepth max traversal depth
     */
    public void setMaxSearchDepth(int searchDepth) {
        writeConfig("maxDepth", String.valueOf(searchDepth));
    }
    public boolean isIncludePathName() {
        return getBoolean("includePathName");
    }
    public void setIncludePathName(boolean value) {
        writeConfig("includePathName", String.valueOf(value));
    }
    public boolean isShowHidden() {
        return getBoolean("showHidden");
    }
    public void setShowHidden(boolean value) {
        writeConfig("showHidden", String.valueOf(value));
    }
    public boolean isDepthFirst() {
        return getBoolean("depthFirst");
    }
    public void setDepthFirst(boolean value) {
        writeConfig("depthFirst", String.valueOf(value));
    }
    public Algorithm.Regular getCurrentSearchingAlgorithm() {
        String savedAlg = getConfig("alg");
        try {
            return Algorithm.Regular.valueOf(savedAlg);
        } catch (NullPointerException | IllegalArgumentException e) {
            return Algorithm.Regular.AUTO;
        }
    }
    public Algorithm.Word getCurrentWordSearchingAlgorithm() {
        String savedAlg = getConfig("wordAlg");
        try {
            return Algorithm.Word.valueOf(savedAlg);
        } catch (NullPointerException | IllegalArgumentException e) {
            return Algorithm.Word.NAIVE;
        }
    }
    public Algorithm.Regex getCurrentRegexSearchingAlgorithm() {
        String savedAlg = getConfig("regexAlg");
        try {
            return Algorithm.Regex.valueOf(savedAlg);
        } catch (NullPointerException | IllegalArgumentException e) {
            return Algorithm.Regex.NATIVE;
        }
    }
    public int getCurrentCpuThreads() {
        return getInt("cpuThreads", 4);
    }
    private int getInt(String key, int defaultValue) {
        try {
            return Integer.parseInt(getConfig(key));
        } catch (NumberFormatException e) {
            return defaultValue;
        }
    }
    private boolean getBoolean(String key) {
        return Boolean.parseBoolean(getConfig(key));
    }
    private String getConfig(String key) {
        return configMap.get(key);
    }
    /**
     * Write multiple key-value pairs in one time.
     * <p>
     * Length of {@code keyValues} must be even.
     *
     * @param keyValues key-value pairs
     */
    public void writeConfigs(String... keyValues) {
        for (int i = 0; i < keyValues.length; i += 2) {
            configMap.put(keyValues[i], keyValues[i + 1]);
        }
    }
    public void writeConfig(String key, String value) {
        configMap.put(key, value);
    }
    public void addExcludedDir(String path) {
        excludedDirs.add(path);
    }
    public void removeExcludedDir(String path) {
        excludedDirs.remove(path);
    }
    public Set<String> getAllExcludedDirs() {
        return excludedDirs;
    }
    public void addExcludedFormat(String path) {
        excludedFmts.add(path);
    }
    public void removeExcludedFormat(String path) {
        excludedFmts.remove(path);
    }
    /**
     * Returns a set of all excluded formats.
     * <p>
     * The returned set must not be muted.
     *
     * @return a set of all excluded formats
     */
    public Set<String> getAllExcludedFormats() {
        return excludedFmts;
    }
    public void addCustomFormat(String ext, String description) {
        customFmts.put(ext, description);
    }
    public void removeCustomFormat(String ext) {
        customFmts.remove(ext);
    }
    /**
     * @return a mutable copy of all custom formats
     */
    public Map<String, String> getAllCustomFormats() {
        return new HashMap<>(customFmts);
    }
    /**
     * Clears all user settings, but does not delete data.
     */
    public void clearSettings() {
        configMap.clear();
        deleteFileByName(CONFIG_FILE_NAME);
    }
    /**
     * Clears all user settings and data.
     */
    public void clearAllData() {
        Cache.clearCache();
        clearSettings();
        clearAllHistory();
        deleteFileByName(EXCLUDED_DIRS_NAME);
        deleteFileByName(EXCLUDED_FORMATS_NAME);
        deleteFileByName(CUSTOM_FORMATS_NAME);
    }
    /**
     * Computes the crc32 checksum of a collection of strings.
     * <p>
     * This method returns the same result regardless the order in collection.
     *
     * @param collection the collection of strings to be compute
     * @return the crc32 checksum
     */
    private long computeChecksum(Collection<String> collection) {
        List<String> sorted = new ArrayList<>(collection);
        Collections.sort(sorted);
        CRC32 crc32 = new CRC32();
        for (String s : sorted) {
            crc32.update(s.getBytes());
        }
        return crc32.getValue();
    }
    private void loadAll() {
        configMap = readMapFile(CONFIG_FILE_NAME);
        excludedDirs = readListFile(EXCLUDED_DIRS_NAME);
        excludedFmts = readListFile(EXCLUDED_FORMATS_NAME);
        customFmts = readMapFile(CUSTOM_FORMATS_NAME);
        excludedDirsChecksum = computeChecksum(excludedDirs);
        excludedFmtsChecksum = computeChecksum(excludedFmts);
        customFmtsChecksum = computeChecksum(customFmts.keySet());
    }
    private void saveToDisk() {
        long excDirsCs = computeChecksum(excludedDirs);
        long excFmtsCs = computeChecksum(excludedFmts);
        long cusFmtsCs = computeChecksum(customFmts.keySet());
        writeMapFile(CONFIG_FILE_NAME, configMap);
        if (excDirsCs != excludedDirsChecksum) {
            excludedDirsChecksum = excDirsCs;
            writeListFile(EXCLUDED_DIRS_NAME, excludedDirs);
        }
        if (excFmtsCs != excludedFmtsChecksum) {
            excludedFmtsChecksum = excFmtsCs;
            writeListFile(EXCLUDED_FORMATS_NAME, excludedFmts);
        }
        if (cusFmtsCs != customFmtsChecksum) {
            customFmtsChecksum = cusFmtsCs;
            writeMapFile(CUSTOM_FORMATS_NAME, customFmts);
        }
    }
    private class AutoSaveTask extends TimerTask {
        @Override
        public void run() {
            saveToDisk();
        }
    }
}
package trashsoftware.deepSearcher2.util;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.text.SimpleDateFormat;
import java.util.Date;
public class EventLogger {
    private static final String LOG_DIR = "logs";
    private static final String LOG_BASE_NAME = LOG_DIR + File.separator + "error-";
    private static final String DATE_FMT = "yyyy-MM-dd HH-mm-ss";
    /**
     * Logs complete error message and stack trace to a new log file.
     *
     * @param throwable error
     */
    public static void log(Throwable throwable) {
        createLogDirIfNone();
        SimpleDateFormat sdf = new SimpleDateFormat(DATE_FMT);
        String realName = LOG_BASE_NAME + sdf.format(new Date()) + ".log";
        try (PrintWriter pw = new PrintWriter(new FileWriter(realName))) {
            throwable.printStackTrace(pw);
            pw.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    /**
     * Logs text error message to a new log file.
     *
     * @param message text message
     */
    public static void log(String message) {
        createLogDirIfNone();
        SimpleDateFormat sdf = new SimpleDateFormat(DATE_FMT);
        String realName = LOG_BASE_NAME + sdf.format(new Date()) + ".log";
        try (FileWriter fileWriter = new FileWriter(realName)) {
            fileWriter.write(message);
            fileWriter.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    private static void createLogDirIfNone() {
        File dir = new File(LOG_DIR);
        if (!dir.exists()) {
            if (!dir.mkdirs()) {
                System.out.println("Failed to create log directory.");
            }
        }
    }
}
package trashsoftware.deepSearcher2.util;
import java.util.Locale;
public class NamedLocale  {
    private final Locale locale;
    private final String description;
    NamedLocale(String language, String country, String description) {
        this.locale = new Locale(language, country);
        this.description = description;
    }
    public String getDescription() {
        return description;
    }
    public Locale getLocale() {
        return locale;
    }
    public String getConfigValue() {
        return locale.getLanguage() + "_" + locale.getCountry();
    }
    @Override
    public String toString() {
        return description;
    }
}
package trashsoftware.deepSearcher2.util;
import java.util.HashSet;
import java.util.Set;
public class Util {
    /**
     * Returns the readable {@code String} of <code>size</code>, representing the size of a file.
     * <p>
     * This method shows a number that at most 1,024 and a corresponding suffix
     *
     * @param size the size to be converted
     * @return the readable {@code String}
     */
    public static String sizeToReadable(long size, String bytesString) {
        if (size < Math.pow(2, 10)) return numToReadable((int) size) + " " + bytesString;
        else if (size < Math.pow(2, 20)) return numToReadable((double) size / 1024 + 1) + " KB";
        else if (size < Math.pow(2, 30)) return numToReadable((double) size / 1048576 + 1) + " MB";
        else return numToReadable((double) size / 1073741824 + 1) + "GB";
    }
    public static String separateInteger(long number) {
        return String.format("%,d", number);
    }
    /**
     * Returns the extension (suffix name) of a file's name.
     *
     * @param fileName the file's name
     * @return the extension (suffix name) of a file's name, in lower case.
     */
    public static String getFileExtension(String fileName) {
        int extIndex = fileName.lastIndexOf(".");
        return extIndex == -1 ? "" : fileName.substring(extIndex + 1).toLowerCase();
    }
    @SafeVarargs
    public static <T> Set<T> mergeSets(Set<T>... sets) {
        Set<T> res = new HashSet<>();
        for (Set<T> set: sets) res.addAll(set);
        return res;
    }
    private static String numToReadable(double num) {
        return num == (int) num ? String.format("%,d", (int) num) : String.format("%,.2f", num);
    }
}
package trashsoftware.deepSearcher2.searcher;
import javafx.fxml.FXML;
import org.junit.jupiter.api.Test;
import java.io.File;
import java.util.ArrayList;
import java.util.List;
public class SearcherTest {
    @Test
    void testPrefSetAddDirs() throws Exception {
        PrefSet.PrefSetBuilder psb = new PrefSet.PrefSetBuilder();
        psb.setSearchDirs(List.of(
                new File("E:\\GitHub"),
                //new File("E:\\"),
                new File("E:\\GitHub\\DeepSearcher2"),
                new File("E:\\Programs")
        ));
        psb.setTargets(new ArrayList<>(List.of("x")));
        psb.searchFileName(true);
        PrefSet ps = psb.build();
        for (File f : ps.getSearchDirs()) {
            System.out.println(f + " " + f.getAbsolutePath());
        }
    }
    @Test
    void testEscapes() {
        System.out.println("aaaxxx\ngggfff".indexOf("\n"));
    }
}
